# Definicja kontenera w Dockerfile

### WYJAŚNIJ DOKŁADNIEJ CO ROBI KOMENDA RUN BO NA RAZIE NIE MASZ DALEJ W LEKCJI DOKŁADNEGO WYJASNIENIA KOMEND. MOZE W TAKIM RAZIE TO ZROBIĆ? TE KOMENDY KTORE TUTAJ SA SA NAJCZESCIEJ UZYWANE WIEC POTEM DO NICH WRACAC JESZCZE RAZ TO TROCHE BEZ SENSU

Skoro Wiemy już Czym jest kontener,  to teraz porozmawiaj sobie jak go stworzyć.  Tak naprawdę w przypadku budowy kontara z wykorzystaniem technologii Docker będzie opierał się tylko i wyłącznie o dwa pliki `Dockerfile` oraz `.dockerignore`.

Otwórzmy sobie Dockerfile i omówmy sobie krok po kroku to co się w nim dzieje.

1. `FROM python:3.11-slim-bullseye` - Każdy Dockerfile, Czyli plik specyfikujący proces budowy naszego kontenera, zawsze zaczyna się od `FROM` - Istnieje oczywiście pewien wyjątek ale to pokażę wam później. Teraz co oznacza ta instrukcja `FROM`. Ta instrukcja FROM oznacza bazowy kontener, na podstawie którego będzie budowany nasz kontener. Teraz żeby wyjaśnić wam czym może być ten bazowy kontener. Przejdźmy sobie do naszego Docker Hub. Docker Hub to nic innego jak repozytorium kontenerów. Wejdźmy sobie w zakładkę Explore I zobaczmy co mamy. Mamy obraz Ubuntu,  czyli systemu operacyjnego z którego teraz korzystamy, ale ten kontener z Ubuntu na przykład nie posiada tego interfejsu graficznego, tylko sam terminal. Mamy naszego Pythona, którego my w tym naszym kontenerze użyjemy.  Mamy też redisa i postgressa czyli bazy danych które my  używamy  na naszych zajęciach. I tak naprawdę te komendy `make postgres` i `make redis` które używaliście wcześniej To nic innego jak przygotowane skrypty w bashu napisane przeze mnie, których zdaniem było pobranie obrazów i uruchomienie ich lokalnie. W ten sposób deployowałem sobie tę bazę danych po to żeby można było z nich korzystać. Czyli jak widzicie w Docker Hub znajdują się kontenery które każdy z was może pobrać, użyć go takim jakim już jest zdefiniowany,  albo pobierzemy go i możemy go odpowiednio zmodyfikować na nasze potrzeby. I do tego właśnie służy klauzula FROM.  Czyli ja definiując `FROM python:3.11-slim-bullseye` określam że z Docker Hub pobieram kontener Python  w wersji 3.11. I dalsza specyfikacja `slim-bullseye` określa bardziej szczegółowy typ tego kontenera o czym powiemy sobie troszeczkę później.  na ten moment zostajemy istotne jest dla nas to, że pobieramy kontener z Pythonem 3.11.
   Teraz pytanie jakie musisz sobie zadać to po co to robimy? Można zbudować kontener zaczynając od pustego kontenera.  Czyli ja mógłbym napisać zamiast `FROM python:3.11-slim-bullseye` moge napisać `FROM scratch`. Czyli Startuje z pustym kontenerem. dalej musiałbym zainstalować w środowisku mojego Pythona,  dodatkowe inne jeszcze rzeczy, które mogłyby być potrzebne do prawidłowego funkcjonowania i tak dalej i tak dalej. Musiałbym się sporo napracować. Aby tego uniknąć Ja w swojej definicji `Dockerfile` zaczynam od tego aby określić sobie bazowy kontener, na którym będę budował swój własny. W tym wypadku Pobieram sobie naszego Pythona 3.11, bo na takiej wersji Pythona pracujemy. Jaka jest tego zaleta? Taka, że w swoim kontenerze będę miał już zainstalowane i skonfigurowane wszystko to co zostało zainstalowane i skonfigurowane w tym kontenerze Python 3.11 - dzięki temu ja nie muszę robić tego ręcznie, samemu wszystko instalować i konfigurować. Nie muszę odkrywać koła na nowo. I tak w rzeczywistości będzie wyglądała budowa waszych kontenerów - zaczynać będzie od bazowego obrazu, na którym cały proces  budowy waszego kontenera będzie się opierał. Teraz dlaczego jest to możliwe, dlaczego mogę skorzystać z innego kontenera żeby Zbudować swój kontener. O tym powiem Wam więcej przy tematach warstw. Na ten moment zinterpretujcie `FROM` jako instrukcja, która pobiera obraz bazowy, na którym opieracie budowe swojego własnego kontenera.
2.  `WORKDIR /app` - Drugą komendę którą tutaj określamy jest nasz WORKDIR który określa nam folder roboczy w naszym kontenerze.  Oznacza to że wszelkie dalsze instrukcje zdefiniowane w Dockerfile i wykonywane po tym WORKDIR, będą wykonywane w tym folderze. Ustawienia `WORKDIR` jest bardzo ważne, bo możesz sobie popsuć kontener pokażę wam później dlaczego. Wyobraźcie sobie `WORKDIR` tak jakbyśmy teraz w terminalu uruchomili sobie komende `cd jakas_nazwa_folderu`. Przy czym WORKDIR ma tą zaletę, że utworzy ten folder jeśli go nie ma.
3. `COPY . .` - Kolejną komendą którą mamy jest `COPY . .`  która jest trochę nieczytelna.  Ale metoda kopii głównie opiera się właśnie o dwa argumenty.  Po pierwsze co kopiujemy i gdzie to kupiłem. Czyli w naszym przypadku zadziała to taki sposób że do kontenera skopiujemy sobie wszystko to co znajduje się w obecnym folderze w którym zaczniemy budować kontenera. A my zaczeliśmy budować nasz kontener w folderze naszego projektu, zatem cała zawartość projektu zostanie do niego skopiowana - i to jest ta pierwsza kropka. A druga  oznacza lokalizacje w kontenerze gdzie to mamy skopiować - W tym przypadku kropka oznaczać będzie do obecnego `WORKDIRA` które jest ustawiony. Czyli w tym przypadku skopiuj wszystko co znajduje się w folderze,  w którym zaczniemy budowę kontenera, czyl inasz folder z projektem, do folderu `/app` w kontenerze. 
4. `RUN pip install -r requirements.txt` - Dalsza komenda RUN oznacza to jaką komendę chcemy uruchomić w kontenerze podczas jego budowy. Jak już mamy wszystko, czyli mamy Pythona 311 dlatego że budujemy kontener na podstawie obrazu Python 311,  skopiowaliśmy sobie wszystkie nasze pliki które mamy w naszym  w projekcie, To teraz musimy zainstalować te biblioteki w kontenerze abyśmy mogli uruchomić nasze API. Musimy to zrobić ponieważ ten kontener python 3.11 z instrukcji `FROM` Ma w sobie zainstalowane tylko bazowe biblioteki,  czyli musicie sobie to wyobrazić tak jakbyście pracowali na czystym, nowo postawionym środowisku. Zeby nasze Apis zadziałało musimy zainstalować to co potrzebujemy zatem uruchamiamy `pip install -r requirements.txt`.
5. `ENV PYTHONPATH='/app'` - Po zainstalowaniu musimy określić naszą zmienną środowiskową która wskazuje nam na to gdzie znajduje się nasze środowisko pythonowe. W naszym przypadku wszystko siedzi w folderze `/app` Zatem te miejsce wskazujemy jako miejsce gdzie znajduje sie nasz Python interpreter. Gdybyśmy tej zmiennej środowiskowej nie ustawili to domyślnie szuka on Pythonowego interpretera w lokalizacji `/usr/local/` (TODO: sprawdz czy to jest w kontenerze)
6. `EXPOSE 8080` - Następnie w API określiliśmy że nasze API działa na porcie 8080. Wiem że o temacie portów jeszcze nie rozmawialiśmy.  ale dzisiaj już będziemy rozmawiać bo Powolutku będziemy przychodzić na chmurę i w związku z tym pewne tematy sieciowe trzeba będzie poruszyć i zrozumieć.  Na ten moment `EXPOSE 8080` zostawiamy I powiemy o nim sobie troszeczkę później. 
7. `ENTRYPOINT ["python", "src/service/main.py"]` - I ostatni element który kończy `Dockerfile`,  jest to komenda która zostanie uruchomiona w momencie kiedy nasz kontener zostanie uruchomiony. Czyli wszystko od początku do instrukcji `ENTRYPOINT` Jest uruchamiane w procesie budowy kontenera, A z kolei `ENTRYPOINT` określa to co zostanie uruchomione w kontenerze w momencie kiedy będziemy chcieli z kontenera skorzystać, czyli go uruchomić. W naszym przypadku naszą aplikacją jest nasze API do modeli. Zatem `ENTRYPOINT` będzie oznaczał  komendę która pozwoli nasze API uruchomić, Czyli w tym przypadku będzie to wywołanie skryptu `main.py` korzystając z pythona Ty to co do tej pory robiła nasza komenda `make api`. 

Domyślam się, że część instrukcji jest jasna, inna może jeszcze mniej jasna, ale spokojnie. Opis działania pierwszego Dockerfile który tutaj przedstawiłem omówiłem sposób dosyć ogólny, bez wchodzenia w niektóre niuanse i szczegóły. Tak jak powiedziałem będziemy przechodzić od ogółu do szczegółu, od rzeczy prostych do rzeczy trudniejszych I tak naprawdę cały nasz zjazd weekendowy będzie polegał na ciągłym poprawianiu Dockerfile. Więc jeżeli na ten moment pewne instrukcje są dla Was jeszcze nie do końca jasne, to spokojnie - to jest Wasz pierwszy kontakt z Dockerem i my przez cały weekend będziemy w tego Dockerfile patrzyć non stop, te instrukcje budowy kontenera będziemy wałkować cały weekend, więc w końcu wejdzie to w krew. I wraz z kolejnymi tematami będziemy coraz mocniej wchodzić w  instrukcję zawarte w Dockerfile, więc wszystko dla Was z biegiem czasu wyda się oczywiste i jasne. Generalnie powiem Wam, że budowa kontenerów z wykorzystaniem dockera pod względem ilości kodu jest bardzo prosta, tutaj mamy 7 linijek kodu I sprawa jest załatwiona.  I tak samo instrukcji, które warto znać nie jest też niewiadomo ile. Natomiast jak się potem przekonacie w trakcie naszego zjazdu, każda linijka kodu robi naprawdę bardzo dużo I kolejność ułożenia instrukcji w Dockerfile też jest bardzo istotna.  Więc pomimo tego że Dockerfile zajmować będą małą ilość kodu to jednak pisanie ich w sposób efektywny jest wymagające i niekiedy trudne. 

Ale może jakieś pytania macie tego co powiedziałem do tej pory?