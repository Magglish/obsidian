# Statusy

Zanim przejdziemy dalej chce Wam pokazać jeszcze jedną rzecz. Wróćmy do bazowych wartości, włączmy API `make api` i wyślijmy requesta `make request`.
	1. Wysyłając poprawne dane otrzymujemy odpowiedź i `status_code = 200`
	2. Jeżeli teraz coś popsuje w danych wejściowych to otrzymuje odpowiedź z błędem i `status_code = 422`
	3. Co się stanie jeżeli popsuje coś w środku API? Zmieńmy w odpowiedzi decision na `xxx` czyli `PredictDecisionResponse(decision="xxx")`. Zresetujmy API i spróbujmy wysłać `requesta`. Przejdźmy na widok logi API i zobaczmy co się stało. Ok widzimy, że mamy teraz `status_code = 500` - logi API wskazują, że, to co się spodziewaliśmy, przekazaliśmy złą wartość do `PredictDecisionResponse`. To na co my patrzymy to widzimy My, developerzy. Natomiast co widzi klient, będzie w drugim oknie. Na początku widzimy `status_code=500`, na dole jest traceback z błędem, ale to błąd po naszej stronie, bo `response` nie ma metody `.json()`. Delikatnie zmienimy to na:

```python
# print(f"Received {response.json()=}")  
print(f"Received {response.content=}")
```

Teraz jest OK. Spójrzmy jeszcze raz na okno API i na okno z requestem. Tutaj zakomentowałem na chwilę tą linijkę kodu, bo odpowiedź, która przyszła z API jest na tą chwilę zwykłym stringiem, dlatego `request.json()` nie zadziałała, bo odpowiedź nie jest `JSON`. To później zacznie działać jak w API zaimplementujemy poprawną obsługę błędów - to będzie temat na później. Natomiast widzimy, że mamy teraz `status_code=500` oraz informacje `Internal Server Error`. 

Z poziomu klienta/serwisu, który będzie korzystał z Waszego API są najważniejsze dwie informacje, które ze sobą istnieją i jedna bez drugiej nie ma sensu
1. To są oczywiście dane zwrotne z API, które otrzymamy jeżeli nasze żądanie zostanie poprawnie przetworzone. Albo treść błędu jeżeli coś jest nie tak - teraz widzimy treść `Internal Server Error`, natomiast wczesniej były informacje, że dane cechy albo źle przekazaliśmy, albo przekazaliśmy za dużo.
2. Natomiast drugą informacją, która jest bardzo istotna to jest `status_code`, która jak widzieliście przyjmuje różne wartości w zależności od odpowiedzi - widzieliśmy `200`, `422` oraz teraz `500`. 
3. Treść wiadomości nie ma sensu bez status code'a i tak samo sam status_code nie ma sensu bez treści wiadomości - to są dwie nierozerwalne rzeczy i zarówno treść wiadomości musi być jasna i precyzyjna, oraz status code musi przyjąć odpowiednią wartość.
4. Weźmy w takim razie na warsztat status code. Z kolei treścią wiadomości o błędzie zajmiemy się później, kiedy będziemy w API implementować tzw. exception handlery, ale to później.

Sprawa ze statusami jest bardzo prosta:

Istnieje [5 rodzajów statusów](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status). Otworze sobie dokumentację tych statusów, które stworzyła Mozzila, żeby łatwiej Wam to wytłumaczyć. Przy okazji uruchomimy sobie przeglądarke z opcją Networking żeby móc podejrzeć jak nasze zapytania są przetwarzane.

1. 1xx - Pierwsza grupa statusów to statusy informacyjne, informujące o tym, że zapytanie zostało otrzymane i jest przetwarzane. W rzeczywistości praktycznie nie zauważalne statusy. Powiem szczerze, że nawet nie wiem jak utworzyć zapytanie żeby móc mieć wgląd w nie. Te statusy można określić jako techniczne. Wasze API nigdy takich statusów nie zwróci.
2. 2xx - Druga grupa statusów informuje o tym, że zapytanie zostało poprawnie przetworzone. W zależności od kodu odpowiedzi wynik tego przetwarzania może być różny. 
	1. `200` - Jeżeli spojrzymy sobie jakie mamy statusy to pierwszym statusem jest 200 - to już widzieliśmy w naszym API, w momencie kiedy zapytanie wysłane do niego zostało poprawnie przetworzone. Otrzymywaliśmy decyzje z modelu oraz `status_code = 200`.
	2. `201` - Created czyli dany zasób został stworzony. Np. gdybyśmy stworzyli API, które przetwarza dane i coś tworzy np. zapisuje nowy obiekt w bazie danych to wtedy nasze API powinno zwrócić `status_code = 201`
	3. `202` - Zapytanie zostało zaakceptowane, przetworzone, ale tak na prawdę nasze API nie ma co zwrócić. To jest specjalny case, który też możecie spotkać się w momencie projektowania API do modeli MLowych, które bardzo długo przetwarzają zapytania - wtedy serwis opiera się o schemat kolejkowania. To jest znacznie bardziej zaawansowany case, z którym rzadko się spotkacie, ale omówie go później przy tematach zaawansowanych.

Nie będę oczywiście omawiał wszystkich statusów bo to jest ich za dużo i podczas budowy API do serwisu MLowego będzie używać naprawde tylko kilku z nich. Natomiast omówie tylko z nich z grup tak żebyście mogli złapać kontekst czego dana grupa statusów dotyczy.

4. 3xx - informują klienta o tym, że musi być podjęta dodatkowa akcja w celu skończenia przetwarzania zapytania. Statusy te wykorzystywane są do ustawiania przekierowań.
5. 4xx - statusy z tej grupy informują o błędzie klienta
6. 5xx - serwer informuje klienta o błędzie po stronie serwera, które uniemożliwiają przetworzenie zapytania