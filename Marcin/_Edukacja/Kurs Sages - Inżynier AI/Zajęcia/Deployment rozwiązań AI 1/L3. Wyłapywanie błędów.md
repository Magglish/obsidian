# Wyłapywanie błędów

[[L1. Logowanie|Ten moduł do przerobienia dopiero po przerobieniu całego logowania]]

Jeżeli myśleliście, że skończyliśmy z logowaniem, to jesteście w błędzie. Logowanie wygląda teraz naprawdę fajnie - mamy potrzebne metadane - czas oraz rodzaj logu - oraz correlation id dzieki ktoremu mozemy bez problemu powiazac logi z danym requestem.

Chciałbym Wam pokazać dwa przypadki, w których nasze logi jeszcze zawodzą:

1. Pierwszy case, zobaczmy jakie logi dostaniemy w momencie kiedy ktoś wyśle zapytanie z błędnymi danymi. Zróbmy `make request` z błędnymi wartościami. Klient/server oczywiście dostanie odpowiedź zwrotną ze statusem 422 i informacja co jest złe, ale spójrzmy na to co my mamy w API. Okazuje, się że nie mamy żadnych logów. Oczywiście pojawia się informacja jaka tutaj widzicie:
   `INFO:     127.0.0.1:38058 - "POST /decisions HTTP/1.1" 422 Unprocessable Entity`
   Ale te logi są rzucane przez nasze środowisko uruchomieniowe `uvicorn.run(...)`, który mamy w `if __name__ == "__main__"` i można też skonfigurować logera, który zaimplementowany jest w `uvicorn` po to aby rzucał nam takimi samymi treściami jak nasz `logger` oraz żeby logi z `uvicorn` mogłybyć wysyłane do usługi, w której potem te logi będziemy analizować... ale z mojego punktu widzenia lepiej jest stworzyć własnego logera i go skonfigurować, niż bawić się konfiguracje logerów w konkretnych bibliotekach - z tym jest zdecydowanie za dużo roboty. Więc najlepiej jest założyć z góry jedną prostą rzecz: będziesz widział logi tylko te, które sam sobie zaimplementujesz. W naszym przypadku, w usługach pozwalających widzieć logi, będziecie widzieć tylko to co zaznaczam, a tego co zaznaczam już nie. 
   Zatem jak widzicie, nie dostaliśmy żadnej informacji o tym, że jakiś request nie przeszedł walidacji. Pytanie jakie możemy sobie zadać to czy logować takie casey? W końcu jest to problem po stronie użytkownika, który otrzymał jasną treść, że źle wysłał dane i ma też informacje jakie są akceptowalne wartości. Więc decyzja należy do Was czy chcecie to logować i czy Wam się to przyda. Ja osobiście loguje takie rzeczy bo chce osobiście widzieć pełne użycie mojego API. Pamiętajcie, że oprócz logów będzie też monitoring API i np. na monitoringu bedziecie widzieć, że przyszło 100 requestów a w logach nic nie ma... może to być zastanawiające dlaczego. A tak przynajmniej będzie informacja, że 100 requestów nie zostało przetworzonych bo po prostu ktoś wysłał złe dane.
2. To teraz drugi case, znacznie poważniejszy. To sytuacja kiedy rzucony zostanie błąd w naszym API. Załóżmy, że w endpoincie decisions pojawił się nam `KeyError` i zobaczmy co dostaliśmy. Znowu powtórze się, tutaj jest błąd rzucany przez `uvicorn` ale nie bedzie on dostepny w uslugach do analizy logów. Dlatego patrzymy tylko na to co nasze logi wypisują. I zobaczmy co się stało. Nasze logi urwały się w pewnym momencie. Nie mamy w ogóle żadnych informacji o błędzie. Nic kompletnie. Ten case jest bardzo poważny, bo to już jest problem w naszym API, konkretnie w naszej implementacji, a nie problem ze źle wysłanymi danymi przez klienta czy server. Jak sobie z tym poradzić? Na szczęście FastAPI dostarcza nam bardzo fajnych mechanizmów jak sobie z tym poradzić. 

Zacznijmy na rozgrzewkę od pierwszego case'u - czyli problem po stronie użytkownika, wysłał złe dane.

To co wykorzystamy w naszym API to metoda `exception_handler` z zainicjalizowanej `app`, czyli 

```python
@app.exception_handler(...)
```

Aby obsłużyć pierwszy case to musimy zaimportować sobie dwie rzeczy z FastAPI:

```python
from fastapi.exception_handlers import request_validation_exception_handler
from fastapi.exceptions import RequestValidationError
```

FastAPI, tak jak sami widzicie, jest w stanie samo obsłużyć walidacje danych i zwrócić odpowiednią odpowiedź do klienta/servera z czym jest problem tak jak mamy to tutaj widoczne w terminalu.

To co my teraz robimy w tym celu to do oryginalnej implementacji FastAPI, dodamy tylko i wyłącznie jedną rzecz: nasze logowanie błędu.

Tworzymy sobie funkcje o nazwie:

```python
async def validation_exception_handler(request: Request, exc: RequestValidationError):
```
Która musi przyjąc requesta oraz wyjątek `exc` aby FastAPI mogło tego użyć

Teraz dodajemy returna
```python
return await request_validation_exception_handler(request, exc)
```

Czyli funkcja od FastAPI, która pozwoli nam na obsługę tego błędu.

I zostało nam jeszcze udekorowanie tej funkcji, aby oznaczyć to jako funkcję, która wyłapuje nam ten konkretny wyjątek, czyli:

```python
@app.exception_handler(RequestValidationError)
```

Gdybyśmy teraz to zostawili w takiej postaci, to ten kod bedzie działał tak samo jak wbudowana obsługa tego błędu, która już jest w FastAPI. Ale my to robimy po to aby dodać jeszcze logowanie do naszego API. Zatem brakuje nam jeszcze jednej linijki:

```python
logging.warning(f"Validation didn't pass for body = {exc.body}, details = {exc.errors()}")
```

Cały kod:

```python
@app.exception_handler(RequestValidationError)  
async def validation_exception_handler(request: Request, exc: RequestValidationError):  
    logging.warning(f"Validation didn't pass for body = {exc.body}, details = {exc.errors()}")  
    return await request_validation_exception_handler(request, exc)
```

To teraz włączmy nasze API i zobaczmy jak to wygląda. Wyślijmy requesta z błędnymi danymi. Ok czyli od strony klienta widzicie, że wszystko jest OK. Dostałem informacje co jest nie tak. A teraz spójrzmy w logi naszego API.

I widać, że dostajemy ładny wpis w logach, że dane zapytanie o body takim i takim nie przeszło walidacji wraz ze szczegółami co nie pasuje. W dodatku zobaczcie... że ten request ma jeszcze ID. Zatem gdyby w waszym kodzie było logowane jeszcze coś innego to bez problemu możnaby te wpisy w logach ze sobą powiązać i analizować wspólnie.

Ok pierwszy przypadek mamy rozwiązany, natomiast z drugim przypadkiem będzie troche trudniej bo trzeba przyjąć pewne założenia w projektowaniu naszego API żeby to się udało.

Wrócmy sobie na chwile do naszego kodu, który implementował wczytanie modelu. W metodzie `_load_model` mamy wyłapanie błędu i zlogowanie jego treści. Natomiast w rzeczywistości treba przygotować się na to że API zwróci dowolny błąd i musimy być w stanie go wyłapać i zlogować.

Aby móc to zrealizować, trzeba przyjąć pewne założenie w projektowaniu API - i tutaj Was może Was zaskoczę, ale generalnie przy projektowaniu API czy jakichkolwiek innych usług/serwisów/rozwiązań, które będą przez Was implementowane i wdrażane kierować się prostą zasadą: ZAWSZE definiować słowe własne wyjątki i używać tylko ich w swoim kodzie i nigdy nie używać żadnych wbudowanych wyjątków, które są dostępne w Pythonie. Nawet jeżeli błąd wystapił taki, że pythonowy wyjątek byłby w tym miejscu właściwy, to i tak zdefiniuj swój własny błąd. Dlaczego tak powinniśmy robić? Z dwóch powodów:

1. Pierwsza sprawa - rzucanie wyjątkami oraz logowanie ich treści powinno być maksymalnie precyzyjne. Tak żebyście dokładnie wiedzieli co się zadziało w Waszym API. I na to składa się wiele czynników: 
	1. sama nazwa wyjątku musi być precyzyjna
	2. treść która wchodzi w logging też musi być precyzyjna
	3. warto do logowania dodać wszelkie metadane tak aby można było bardzo łatwo odtworzyć błąd
	4. oraz traceback - na szczęście on zawsze będzie dodawany jeżeli użyjemy odpowiednich funkcji jak np. `logging.exception(...)` i o to nie musimy się martwić
	Zatem zdefiniowanie swoich własnych wyjątków pozwala Wam na polepszenie jakości rzucanych wyjątków i ich treści - znacznie łatwiej jest później naprawiać błędy w Waszym API.
2. Druga sprawa - Python dostarcza wielu wbudowanych wyjątków, które mogą pokryć praktycznie wszystkie Wasze przypadki. Jednakże w bibliotekach których używacie też są zdefiniowane ich własne błędy:

Pokaż np. `redis.exceptions`, `from pandas.errors`

właśnie ze względu na punkt 1-wszy który opowiedziałem oraz drugi aspekt jest taki, że można bardzo łatwo nimi zarządzać oraz co najważniejsze JE WYŁAPYWAĆ. 

Na pewno o tym wiecie, że każdy wyjątek który jest zdefiniowany dziedziczy po klase `Exception`, więc tak na prawdę jak w try except umieścimy Exception to łapiemy każdy wyjątek jaki zostanie rzucony w Pythonie. I my ten fakt dziedziczenia wykorzystamy w naszym API, ale nie będziemy wyłapywać generalnego błędu Exception, tylko zdefiniujemy sobie swoją własną abstrakcję, po której będą dziedziczyć nasze błędy w API. 




	