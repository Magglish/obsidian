# Protokół HTTP.

1. Wiem, że jest sporo teorii i troche mniej kodzenia, ale zapewniam Wam, że później się to zmieni. Na ten moment omawiamy fundamenty. Wiemy jakie mamy rodzaje endpointów, wiemy jak zdefiniować odpowiednie klasy w pydantic żeby móc przychodzące dane przetworzyć, wiemy też w jakim przypadku, które status codey zostaną zwrócone. Mamy podstawową wiedzę, natomiast żeby pójść dalej i implementować coraz bardziej skomplikowane rzeczy i przedewszystkim zrozumieć dlaczego to robimy w taki sposób. Musimy sobie omówić dwie najważniejsze rzeczy w całym naszym programie. Co to jest protokół HTTP, który służy do komunikacji pomiędzy dwoma serwisami, oraz co oznacza REST API... czyli te słówko REST, bo to ma bezpośrednie implikację na to jak implementujemy nasze API. Zatem żeby móc ruszyć dalej z kolejnymi implementacjami, musimy omówić te dwa zagadnienia - czym jest HTTP i czym jest REST.
2. Zacznijmy od początku - na pewno każdy z Was słyszał o skrócie HTTP - czyli Hypertext Transfer Protocol - jest to protokół, na którym bazuje cała komunikacja w internecie. 
3. Protokół HTTP istnieje od 1990 roku, czyli od momentu kiedy tak na prawdę istnieje World Wide Web, początkowo stworzony do odczytywania dokumentów HTML na stronach czyli właśnie Hypertext Markup Language. Ale od momentu jego powstania minęło już ponad 30 lat i przez ten czas ewoluował. Tak na prawdę mamy aż 4 rożne wersje HTTP - powiem o nich więcej później. Obecnie służy do wymiany danych pomiędzy dwoma obiektami w sieci i nie tylko już wymieniamy się samymi dokumentami HTML, ale również samym tekstem, zdjęciami, video, skryptami itd.
4. HTTP jest bardzo prostym protokołem - opiera się o żądania (requesty), czyli np. prośby pobranie danego zasobu, wysłanie danych i przetworzenie ich np. wykonanie predykcji, czy stworzenie nowego rekordu w bazie i odpowiedzi (response), które zwracają informację zwrotną czy dana operacja, opisana w żądaniu się wykonała i z jakim skutkiem. Czyli to co właśnie do tej pory analizowaliśmy i zaimplementowaliśmy - naszym żądaniem jest prośba o wygenerowanie predykcji i w odpowiedzi otrzymujemy status (sukces, czy porażka) wraz z tą predykcją bądź informacją zwrotną co jest nie tak na wypadek jakichś problemów.
5. Protokół HTTP jest protokołem tekstowym, co oznacza dla nas, że jest human-friendly, tzn. my możemy zobaczyć jakie wiadomości wysyłamy do serwisu oraz my możemy też zobaczyć jaką odpowiedź otrzymamy serwisu w formacie tekstowym (*trzeba teraz odpalić Mozille i pokazać Network bo tam można zobaczyć surowy response*). To co my widzimy w Networku jest ładnie wyświetlane nam przez GUI przeglądarki, ale w rzeczywistości jak klikniemy sobie opcję "Raw" w prawym górnym rogu, zobaczymy surową odpowiedź jaką otrzymaliśmy ze strony (albo [tutaj możemy pokazać](https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview#http_flow). I jak widzimy to jest po prostu czysty tekst z masą różnych informacji, o których powiem więcej później. Sprawdźmy też jak to wygląda w naszym przypadku: 
Uruchomimy API. Potem **treść `send_example_request.py` skopiować do pythonowej konsoli żeby mieć obiekt response** i następnie:

```python
from requests_toolbelt.utils import dump
data = dump.dump_all(response)
print(data.decode('utf-8'))
```

Spójrzmy na to co widzimy: Te znaczki większości, mniejszości oznaczają czy to jest żadanie czy odpowiedź. Zaznaczony obszar przeze mnie to żądanie, a ten niżej to odpowiedź
1. Mamy informację jakiego typu żądanie wysyłamy - widzimym że jest to `POST`
2. Następnie jest informacja o endpoincie `/predict_decision` gdzie wysyłamy nasze żądanie
3. Potem jest informacja o wersji protokołu, w tym przypadku `HTTP 1/1` - o różnych wersjach HTTP powiem później.
4. Następnie mamy tzw. nagłówki (czyli `headers` po angielsku) czyli krótko mówiąc metadane o naszym zapytaniu. I spójrzmy jakie metadane wy 

5. 

[Dokumentacja HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview)
https://blog.bytebytego.com/p/how-does-https-work-episode-6#%C2%A7how-does-https-work
https://blog.bytebytego.com/p/ep62-why-does-google-use-monorepo#%C2%A7important-things-about-http-headers-you-may-not-know
https://blog.bytebytego.com/p/ep21-is-https-safe-also#%C2%A7is-https-safe
[Usage stats of HTTP/2](https://w3techs.com/technologies/details/ce-http2)
[Usage stats of HTTP/3](https://w3techs.com/technologies/details/ce-http3)

