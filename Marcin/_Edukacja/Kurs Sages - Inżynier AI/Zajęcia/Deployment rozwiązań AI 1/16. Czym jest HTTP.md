# Protokół HTTP.

1. Wiem, że jest sporo teorii i troche mniej kodzenia, ale zapewniam Wam, że później się to zmieni. Na ten moment omawiamy fundamenty. Wiemy jakie mamy rodzaje endpointów, wiemy jak zdefiniować odpowiednie klasy w pydantic żeby móc przychodzące dane przetworzyć, wiemy też w jakim przypadku, które status codey zostaną zwrócone. Mamy podstawową wiedzę, natomiast żeby pójść dalej i implementować coraz bardziej skomplikowane rzeczy i przedewszystkim zrozumieć dlaczego to robimy w taki sposób. Musimy sobie omówić dwie najważniejsze rzeczy w całym naszym programie. Co to jest protokół HTTP, który służy do komunikacji pomiędzy dwoma serwisami, oraz co oznacza REST API... czyli te słówko REST, bo to ma bezpośrednie implikację na to jak implementujemy nasze API. Zatem żeby móc ruszyć dalej z kolejnymi implementacjami, musimy omówić te dwa zagadnienia - czym jest HTTP i czym jest REST.
2. Zacznijmy od początku - na pewno każdy z Was słyszał o skrócie HTTP - czyli Hypertext Transfer Protocol - jest to protokół, na którym bazuje cała komunikacja w internecie. 
3. Protokół HTTP istnieje od 1990 roku, czyli od momentu kiedy tak na prawdę istnieje World Wide Web, początkowo stworzony do odczytywania dokumentów HTML na stronach czyli właśnie Hypertext Markup Language. Ale od momentu jego powstania minęło już ponad 30 lat i przez ten czas ewoluował. Tak na prawdę mamy aż 4 rożne wersje HTTP - powiem o nich więcej później. Obecnie służy do wymiany danych pomiędzy dwoma obiektami w sieci i nie tylko już wymieniamy się samymi dokumentami HTML, ale również samym tekstem, zdjęciami, video, skryptami itd.
4. HTTP jest bardzo prostym protokołem - opiera się o żądania (requesty), czyli np. prośby pobranie danego zasobu, wysłanie danych i przetworzenie ich np. wykonanie predykcji, czy stworzenie nowego rekordu w bazie i odpowiedzi (response), które zwracają informację zwrotną czy dana operacja, opisana w żądaniu się wykonała i z jakim skutkiem. Czyli to co właśnie do tej pory analizowaliśmy i zaimplementowaliśmy - naszym żądaniem jest prośba o wygenerowanie predykcji i w odpowiedzi otrzymujemy status (sukces, czy porażka) wraz z tą predykcją bądź informacją zwrotną co jest nie tak na wypadek jakichś problemów.
5. Protokół HTTP jest protokołem tekstowym, co oznacza dla nas, że jest human-friendly, tzn. my możemy zobaczyć jakie wiadomości wysyłamy do serwisu oraz my możemy też zobaczyć jaką odpowiedź otrzymamy serwisu w formacie tekstowym (*trzeba teraz odpalić Mozille i pokazać Network bo tam można zobaczyć surowy response*). To co my widzimy w Networku jest ładnie wyświetlane nam przez GUI przeglądarki, ale w rzeczywistości jak klikniemy sobie opcję "Raw" w prawym górnym rogu, zobaczymy surową odpowiedź jaką otrzymaliśmy ze strony (albo [tutaj możemy pokazać](https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview#http_flow). I jak widzimy to jest po prostu czysty tekst z masą różnych informacji, o których powiem więcej później. Sprawdźmy też jak to wygląda w naszym przypadku: 
Uruchomimy API. Potem **treść `send_example_request.py` skopiować do pythonowej konsoli żeby mieć obiekt response** i następnie:

```python
from requests_toolbelt.utils import dump
data = dump.dump_all(response)
print(data.decode('utf-8'))
```

Spójrzmy na to co widzimy: Te znaczki większości, mniejszości oznaczają czy to jest żadanie czy odpowiedź. Zaznaczony obszar przeze mnie to żądanie, a ten niżej to odpowiedź
1. Mamy informację jakiego typu żądanie wysyłamy - widzimym że jest to `POST`
2. Następnie jest informacja o endpoincie `/predict_decision` gdzie wysyłamy nasze żądanie
3. Potem jest informacja o wersji protokołu, w tym przypadku `HTTP 1.1` - o różnych wersjach HTTP powiem później.
4. Następnie mamy tzw. nagłówki (czyli `headers` po angielsku) czyli krótko mówiąc metadane o naszym zapytaniu. I spójrzmy jakie metadane wysyłamy do naszego API.  
5. Pierwszym z nim jest `host` - ciężko jest mi mówić o czym jest `host`, bo jeszcze nie omówiliśmy tematu czym jest IP, Port, czym jest URL, URI, domeny itd. więc wrócę do tego później. Natomiast na ten moment przyjmijmy, że `host` to po prostu informacja o tym gdzie konkretnie te żądanie ma trafić. 
6. Dalej mamy informacje o `User-Agent` czyli kto wysyła żądanie. Albo będąc bardziej precyzyjny, jest to narzędzie, które w imieniu użytkownika wysyła żądanie. W naszym przypadku mam informacje, że przyszło to z pythonowej bilbioteki `request`. Jeżeli wrócimy do networkingu w naszej przeglądarce to `User-Agent` będzie po prostu informacją o przeglądarce.
7. `Accept-Encoding: gzip, deflate` to są algorytmy, które API może użyć do tego aby skompresować naszą wiadomość, po prostu aby mniej ważyła.
8. `Accept` informuje o tym w jakim formacie zaakceptujemy odpowiedź. W naszym przypadku mamy ustawione na `*/*` - co to oznacza? Gdyby nasz endpoint mógł zwrócić informacje w różnych formatach, np. nie tylko JSON, ale również obrazek czy zwykły tekst, to tym nagłówkiem możemy sterować jakiego formatu odpowiedzi się spodziewamy. Defaultowo ustawiane jest na `*/*`, czyli zaakceptujemy każdy format. Serwis, do którego wysyłamy żądanie ma sam zadecydować, który format będzie najlepszy na podstawie żądania. Natomiast jak spojrzymy sobie na networking to tutaj różne żądania mają ustawione różne wartości w tych nagłówkach, właśnie w zależności od tego czego spodziewają się wysłać.
9. `Connection` - nagłówek mówiący o nawiązaniu połączenia z serwisem - może przyjąć dwie wartości, albo `keep-alive` czyli połączenie jest cały czas otwarte i kolejne requesty, które będziemy wysyłać do API korzystają już z tego samego połączenia albo `close`, do którego wysyłaliśmy żądanie. To jest już temat bardzo zaawansowany, dlatego, że w komunikacji pomiędzy dwoma serwerami działa jeszcze również protokół TCP i to jest nagłówek używany przez protokół TCP. Krótko mówiąc - dla własnego bezpieczeństwa nie dotykamy tego nagłówka. Jeżeli tutaj będzie `keep-alive` to jest OK, wtedy korzystamy z połączenia który już nawiązaliśmy. Jeżeli byśmy tutaj ustawiali `Connection: closed` to z każdym wysłanym żadaniem musielibyśmy utworzyć połączenie z API na nowo. Ale to już jest temat zaawasowany i nie chce tutaj wnikać w szczegóły działania protokołu TCP.
10. Bardzo ważny nagłówek dla Nas czyli `Content-Type: application/json` - określa jakiego typu dane wysyłamy - w naszym przypadku jest to informacja, że dane przyjdą w schemacie `JSON`. 
I tutaj muszę wrócić na chwilę do `send_example_request.py` bo jeżeli ktoś z Was już tą bibliotekę zna, to wie o tym, że tutaj jest jedna rzecz za dużo, nie potrzebna. Jak spojrzymy sobie na `requests.post(url=url, headers=headers, json=data)` to mamy url, do którego wysyłam żądanie, nagłówki w `headers` oraz parametr `json=data`. Jeżeli skorzystamy z argumentu `json` w bibliotece `request` to nie musimy ustawiać nagłówków na `"Content-Type": "application/json"`  (zakomentuj, zmień i pokaż im). Dlatego ,że ten argument automatycznie dodaje nagłówek `"Content-Type": "application/json"`. Natomiast request mamy parametr `data` i wtedy taki nagłówek jest potrzebny. Tylko dodatkowo `data` wymaga danych w formacie czystego `stringa` a my mu podajemy `dict` i na pewno rzuci nam błędem: zobaczmy `make request`. To wtedy trzeba zaimportować bibliotekę `json` i użyć `json.dumps` -> 
```python
response = requests.post(url=url, headers=headers, data=json.dumps(data))
```
I teraz ten dict zamieniony na tekst zostanie odpowiednio przetransformowany na JSON, zgodnie z nagłówkiem, który ustawiliśmy. Ale żeby sobie pracę ułatwić to wracamy do argumentu JSON. Natomiast te `headers` zakodziłem po prostu z przyzwyczajenia oraz z tego faktu, że w przyszłości będziemy jeszcze dodawać tutaj nagłówki. 
Teraz ktoś może zapytać - dlaczego wysyłamy dane do API w formacie JSON? Czy nie moglibyśmy danych do naszego API wysłać inaczej? Odpowiedź brzmi tak, można wysłać dane w każdym formacie np. tekstowym, ale po prostu praca na JSONa w pythonie jest bardzo łatwa i przyjemna, bo JSON to po prostu pythonowy `dict` a `dict` można bardzo łatwo rozpakować np. podczas inicjalizacji klas (pokaż na przykładzie `PredictRequest`, zainicjuj klase w konsoli na przykładzie dicta `data` z `send_example_request`. Dlatego najwygodniej jest pracować na JSONach. Nie wiem jak jest w innych językach, ale domyślam się, że praca na JSON-owo analogicznych obiektach jest po prostu przyjemna. A suchy tekst trzeba odpowiednio parsować itd. bez sensu.
11. Dalej na końcu mamy `Content-Length` - czyli długość naszych danych w sensie ile znaków tekstowym to zajmuje
12. No i podspodem `body` czyli zawartość requesta - nasze dane do predykcji.

No i otrzymujemy odpowiedż z podobnymi danymi, protokół, status code, treść i nagłówki oraz payload.

Jak widzicie struktura jest jak to się mówi `human-friendly`, jesteśmy w stanie przeczytać to co wysyłamy i to co otrzymujemy normalnie jako tekst, a nie jako jakieś binarne 0 i 1. Chociaż niestety taka reprezentacja tekstowa może się w przyszłości zmienić, ale o tym powiem za chwilę.

3. Dzięki strukturze nagłówków, protokół HTTP przez te wiele lat był i wciąż jest cały czas rozszerzany. Rozszerzalność zastosowania protokołu HTTP może odbywać się właśnie poprzez dodawanie nowych nagłówków. Temat jest spory i nie bede tutaj przynudzał - zainteresowanych jak się protokół HTTP rozwijał odsyłam do bardzo fajnego artykułu [o historii ewolucji HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP) i tam też można zobaczyć jakie nowe nagłówki pojawiały się na przestrzeni czasu . Natomiast to co jest istotne w kontekście dodawania swoich własnych nagłówków to struktura jaką muszą przyjąć: wszelkie customowe, nowe nagłówki, które będziemy chcieli dodać na potrzeby działania naszego serwisu muszą zaczynać od `X-` i potem nasza nazwa. Zobaczmy na networking. Nagłówki bez `X-` to są nagłówki "oficjalne", spotykane wszędzie i wspierane przez wszystkie serwisy, strony internetowe itd. Natomiast nagłówki z `X-` - tak jak tu widzicie - to są customowe nagłówki dodawane przez serwis `stackoverflow.com`. W jakim celu są one stosowane - zastosowania mogą być różne - inne serwisy, które korzystają z danych ze stackoverflow mogą uzależniać swoje działanie właśnie od wartości w nagłówkach.

4. My na naszym kursie będziemy korzystać zarówno z nagłówków oficjalnych, przy temacie zabezpieczania API i autoryzowania się do niego oraz ze swoich własnych nagłówków przy tematach logowania tego co się w API dzieje.

5. I ostatni temat bardzo ważny w protokole HTTP to to, że protokół HTTP z definicji jest `stateless` czyli `bezstanowy`, ale nie jest `sessionless` czyli `bezsesyjny`. O co chodzi? 
	1. HTTP jest `stateless` - Chodzi o to, że każde kolejne żądania wysyłane do API są po prostu niezależne od siebie. Protokół HTTP **nie wymaga**, aby nasze API/serwis przechowywał jakiekolwiek informacje o użytkowniku, który właśnie teraz wysyła żądania, po to aby móc przetwarzać kolejne zapytania wysyłane przez niego.
	2. Natomiast HTTP nie jest `sessionless` - Chodzi o to, że korzystając ze struktury nagłówków możemy w nich przechowywać informację o danym stanie. W tym celu powstały ciasteczka, które są po prostu jednym z nagłówków (zobacz networking). Cookies przechowują w sobie na tyle dużo informacji, że mają swoją dedykowaną zakładkę w Networkingu, gdzie można podejrzeć co tam mamy. Co może wchodzić w skład ciasteczka? Wszelkie dodatkowe informacje o waszych ustawieniach, preferencjach, historii przeglądania, to co wrzuciliście sobie do koszyka w jakimś sklepie. Również w tematach security, bo mogą być tam przechowywane metadane o waszych kontach, sesji, logowaniu itd. - polecam [bardzo fajny artykuł od Google'a o tym jak wykorzystuje  ciasteczka](https://policies.google.com/technologies/cookies?hl=en-US). Skracając, w ciasteczkach umieszczane są wszelkie dane, które mogą wspomóc przetwarzanie requestów i spowodować że z danej strony korzysta się przyjemniej.
	Żeby łatwiej dostrzec różnice pomiędzy tymi dwoma punktami: że HTTP jest `stateless` ale nie jest `sessionless`, można to wytłumaczyć na przykładzie dodawania produktów do koszyków. Każde nasze kliknięcie na stronie jest oddzielnym żądaniem. Każde kolejne żądanie, request dodania produktu do koszyka nie musi wiedzieć nic o poprzednich, żeby były poprawnie przetworzone. Natomiast wśród nagłówków jest ustawione ciasteczko, które pozwala na powiązanie przez serwis wszystkich requestów przychodzących od nas, aby móc wyświetlić nam koszyk w pełni. (TO JESZCZE ZWERYFIKUJ W INNYM ŹRÓDLE, BO PRZYKŁAD JEST Z GŁOWY)

Teraz tak - domyślam się, że niektóre osoby z Was, mające większe doświadczenie z API i rozumienie jak działa protokół HTTP mogą się teraz ze mną niezgodzić, że HTTP jest bezstanowy `stateless` (czyli mieć obiekcję do punktu 1-go). I tutaj przyznam im rację, dlatego, że ten opis, który został przezemnie zaprezentowany tyczy się HTTP w wersji 1.1.
Protokół HTTP istnieje od lat 90, wersja 1.1 został opublikowany w 1997 roku. Natomiast na przestrzeni ostatnich 30 lat powstał protokół HTTP w wersji 2, dokładnie w 2015 roku został ustandaryzowany ([wykorzystanie HTTP 2](https://w3techs.com/technologies/details/ce-http2)), oraz w wersji 3, nad którym wciąż są pracę ale niektóre strony z niego korzystają ([wykorzystanie HTTP 3](https://w3techs.com/technologies/details/ce-http3)). Nie chce tutaj wchodzić w szczegóły techniczne różnic pomiędzy tymi protokołami - jeżeli kogoś interesuje to jest bardzo fajny artykuł o [ewolucji protokołu HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP) i tam wszystkie różnice są opisane. Natomiast to co się zmienia w kolejnych wersjach to to, że po prostu stają się one szybsze - zmiany są na bardzo niskim poziomie, na nawiązywaniu połączenia między serwerami. Ale zmiany też dotyczą tych zależności między requestami i np. w protokole HTTP2 są pewne elementy, które powodują zależności pomiędzy kolejnymi żadaniami zatem HTTP/2 od wersji dwa jest `stateful`. Inna kwestia, bardziej dla nas istotna jest to, że HTTP 2 jest już protokołem binarnym, a nie tekstowym, zatem żądania w wersji HTTP/2 to są po prostu dla nas same 0 i 1 i nie będziemy mogli podejrzeć tak ładnej żadania i odpowiedzi. Chociaż z tego co czytałem i sprawdziłem, to wciąż przeglądarki czy też bilbioteki oferują to aby przetłumaczyć 0 i 1 na tekst, w momencie korzystania z HTTP 2.0, aby wciąż móc odczytywać w pełni wiadomości tak jak to było w HTTP 1.1. (*Zobacz w mozzili networking na stackoverflow, tam są zapytania z HTTP 2 i 3 i można podejrzeć tekst*)

Teraz dlaczego mówie o tych różnych wersjach HTTP i jakie to ma powiązanie z naszymi MLowymi serwisami?
1. Po pierwsze - chce żebyście mieli szerszy pogląd na to jak wygląda komunikacja w sieci. Nasze API to będzie kolejny serwis, dostępny w internecie, schowany za jakimś IP i domeną, z którą też inne serwisy czy my sami także będziemy komunikowali się za pomocą protokołu HTTP. Jak spojrzymy sobie w logi naszego API, to widzimy taką informację, że przyszło zapytanie z protokołem HTTP w wersji 1.1. Jest możliwe, aby nasze API działało na protokole HTTP/2.0 czy nawet HTTP/3.0 - po prostu trzeba zmienić server, który uruchamia nasze API - mam na myśli `uvicorn` na `hypercorn`, którego użyliśmy w `main.py`. Ale ja o tych "środowiskach uruchomieniowych" będę mówił później. 
2. Jakie znaczenie mają różne wersje HTTP dla Nas, inżynierów ML, w trakcie projektowania API? Z wysokiego poziomu, czyli samej implementacji nie zmienia się nic. To czy użyjemy HTTP 1.1, czy 2.0 czy 3.0, nie zmienia tego jak piszemy kod i implementujemy go. Ba, nawet nowe wersje HTTP nie narzucają nam jakichś zmian w kodzie. Wersje HTTP wpływają na bardzo niskopoziomowe aspekty, dotyczące nawiązywania samego połączenia pomiędzy mną a API - i zmiany w kolejnych wersjach HTTP dotyczą właśnie tych niskopoziomowych aspektów. 
3. Teraz co ja rekomenduję? To zależy od dwóch czynników:
		1. Po pierwsze - od wiedzy i doświadczenia implementującego API. Jeżeli ktoś nie zna tematów różnych wersji HTTP. Zostać przy tym co jest domyślne.
		2. Druga sprawa -  Jeżeli mamy bardzo restrykcyjne założenia co do szybkości działania API, i ono musi zwracać predykcję w naprawdę jakims bardzo krótkim czasie rzędu kilkudziesięciu milisekund, to wtedy warto rozpatrzyć takie zaawansowane optymalizacje jak zmiana protokołu HTTP na wyższą i zrezygnowanie z podstawowego środowiska uruchomieniowego, który FastAPI proponuje `uvicorn` na coś bardziej fancy. Natomiast jeżeli nie projektujemy API w takich warunkach, to ja proponuje nie dotykać tych aspektów wersji HTTP i zostawić tak jak jest domyślnie. Jeżeli natomiast chcemy, to nie oszukujmy się ale inżynierowe ML nie będą ekspertami od sieci, bo zmiany w protokole są na naprawdę niskopoziomowych warstwach i moim zdaniem warto skonsultować się tutaj będzie z administratorami systemów czy DevOpsami, którzy takie tematy znacznie lepiej ogarniają od nas i czy zmiany mają sens i też samemu mocno zgłębić temat i przedewszystkim zrobić testy czy faktycznie widzimy poprawę.

Troche się rozgadałem, więc myślę, że czas sobie to wszystko podsumować:

1. protokół tekstowy/binarny (w zależności od wersji) - możemy podejrzeć to co wysyłamy i to co otrzymujemy z API
2. oparty o żądania (request) i odpowiedzi (response) 
3. metody - GET, POST, PUT, DELETE itd. - określające co dane żądanie "chce" od serwisu
4. status code - informacja o przetworzeniu żądania (1xx, 2xx, 3xx, 4xx, 5xx)
5. headers - nagłówki ze wszelkimi metadanymi, pozwalającymi lepiej określić jak przetworzyć żadanie i czego oczekujemy w odpowiedzi. nagłówki są bardzo istotnym elementem bo pozwalają na rozszerzenie protokołu HTTP bądź mogą mieć wpływ na działanie samego serwisu. My sami możemy dodawać customowe nagłówki zaczynające się od `X-` i wykorzystać w naszym serwisie tak jak chcemy. Wśród nagłówków największym nagłówkiem jest `ciasteczko` 
6. trzy wersje HTTP 1.1, HTTP 2.0 oraz HTTP 3.0 - wprowadzające optymalizacje na bardzo niskim poziomie, transparentnym dla developera - to jaką wersję wybierzecie nie ma wpływu na implementację (kod) jaki tworzycie. Uzysk można zobaczyć w czasie przetwarzania.

Dla poszerzenia naszych horyzontów i ciekawostki: Protokołów jest znacznie więcej "w naturze" i dla własnego rozwoju i ciekawości polecam zgłębić temat innych protokołów, które są wśród Nas:

1. (S)FTP - (Secure) File Transfer Protocol - czyli protokół definiujący to jak możemy dzielić się plikami
2. SMTP - Simple Mail Transport Protocol - protokół definiujący jak możemy wysyłać maile
3. TCP (Transmission Control Protocol) oraz UDP (User Datagram Protocol)  - najważniejsze protokoły. Tak na prawdę protokół HTTP definiuje to jak powinna wyglądać komunikacja w sensie zapytania i odpowiedzi. Natomiast, to co już wielokrotnie wspominałem, o nawiązaniu połączenia pomiędzy np. mną a API, nie decyduje protokół HTTP, a protokoły TCP w wersji HTTP 1.1 i 2.0 oraz UDP w wersji 3.0. Więc jeżeli właśnie kogoś zainteresowały takie niskopoziomie zmiany w protokołach HTTP i chciałby zgłębić o co tam chodzi, to najpierw trzeba zapoznać się z protokołami TCP i UDP, a dopiero potem ze zmianam  




Jest to powiązane ze sposobem w jakim ten protokół się rozwija:

1. 
   
[Krytyka bycia Stateless przez HTTP](https://stackoverflow.com/questions/13200152/why-is-it-said-that-http-is-a-stateless-protocol)

[Dokumentacja HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview)
https://blog.bytebytego.com/p/how-does-https-work-episode-6#%C2%A7how-does-https-work
https://blog.bytebytego.com/p/ep62-why-does-google-use-monorepo#%C2%A7important-things-about-http-headers-you-may-not-know
https://blog.bytebytego.com/p/ep21-is-https-safe-also#%C2%A7is-https-safe
[Usage stats of HTTP/2](https://w3techs.com/technologies/details/ce-http2)
[Usage stats of HTTP/3](https://w3techs.com/technologies/details/ce-http3)

