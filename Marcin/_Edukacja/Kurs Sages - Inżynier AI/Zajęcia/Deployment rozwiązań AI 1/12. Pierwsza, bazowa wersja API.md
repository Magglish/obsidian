# Budowa pierwszego, prostego API

1. Tak jak Wam mówiłem na początku, przez cały zjazd będę prowadził live coding wraz z omawianiem budowy API, problemami z którymi się spotkacie podczas implementowania API do serwisu z modelem MLowym i jak je rozwiązać.
2. API będzie powstawało w sposób iteracyjny, od bardzo prostych implementacji aż do czegoś bardziej zaawansowanego.
3. Zaczniemy sobie oczywiście od napisania czegoś minimalistycznego i jak sami zobaczycie FastAPI pozwala na zbudowanie API w kilku linijkach kodu, ale to oczywiście będzie początek.
4. Zacznijmy od tego aby w folderze `src` zrobić sobie folder `service`, w którym będziemy tworzyć sobie całą naszą implementację i plik `main.py`, który będzie stanowić główny core naszego API.
5. Zaimportujemy sobie podstawowe obiekty z FastAPI:
	1. główny obiekt FastAPI
	```python
	from fastapi import FastAPI  
	```
	2. Klase `Request`, który będzie na ten moment stanowił reprezentację naszego wejścia
	```python
	from fastapi.requests import Request
	```
	3. Klase `JSONResponse`, który będzie na ten moment stanowił reprezentację naszego wyjścia z API
	```python
	from fastapi.responses import JSONResponse
	```
6. Następnie `uvicorn`, który jest środowiskiem uruchomieniowym API dla FastAPI, ale o `uvicornie` i jego działaniu powiemy sobie znacznie później, przy tematach zaawansowanych.
```python
import uvicorn
```
8. Dodatkowo `pandas` oraz `pathlib` który zaraz mi posłuży do wczytania modelu i pracy nad tym co otrzymam w API.
```python
import pandas as pd  
from pathlib import Path
```
9. Naszą abstrakcję modelu scoringowego
```python
from src.models.credit_score import CreditScoringModel
```
10. Następnie zainicjować musimy obiekt FastAPI
```python
app = FastAPI()
```
Sam ten obiekt ma w sobie wiele różnych ustawień, ale bęðziemy do nich sięgać w odpowiednich momentach. Wartości defaultowe są na ten moment wystarczające.
11. Następnie załadujemy sobie nasz model
```python
model = CreditScoringModel(path=Path("models/classifier.pkl"))
```
Krótkie omówienie tego czym ten CreditScoringModel jest:
1. Tak jak Wam mówiłem, inne rzeczy poza API, chce żeby były maksymalnie uproszczone. Nie chce żebyśmy teraz spędzali godziny nad jakąś skomplikowaną implementacją, bo chce żebyśmy skupili się w pełni na budowie API i jej problemów.  
2. Jeżeli będą jakieś dodatkowe rzeczy, które bezpośrednio w trakcie budowy API się nie tworzy, ale są jednak do API potrzebne - tak jak ta abstrackaj wokół modelu scoringowego - to one będą już przeze mnie zaimplementowane, tak żebyśmy zaoszczędzili sobie czasu i skupili się na ważniejszych rzeczach.
3. W dodatku mieliście wcześniej zajęcia z programowania obiektowego więc bez sensu żebym się powtarzał.
4. To co tu widzicie to prosta abstrakcja wokól modelu scoringowego, który ładuje model z pliku, który przechowywany jest w folderze `models` oraz ma opcję ustawienia punktu decyzyjnego, czy też odcięcia - czyli wnioski o kredyt, które charakteryzują się prawdopodobieństwem niespłacenia ich w ciągu ostatnich 12 miesięcu większym od 20% po prostu zostaną odrzucone. 
5. Mamy trzy proste metody:
	1. `predict_proba` - które zwracają nam prawdopodobieństwa dla każdego wniosku - lista floatów
	2. `predict_decision` - decyzje o zaakceptowaniu bądź odrzuceniu i jest to lista decyzji, gdzie decyzja to prosty Enum z definicją dwóch możliwych stanów
	3. `predict_risk_category` - oraz bardzo specyficzne dla problemu oceny wniosków - kategoria ryzyka od której w dużej mierze potem zależy marża banku. Metoda zwraca nam listę kategorii, która tez jest prostym Enumem - 4 kategorie określające górny próg prawdopodobieństwa.
6. Ta abstrakcja, którą tutaj widzicie posłuży nam przez cały zjazd i jak widzicie jest ona bardzo prosta i minimalistyczna bo nie chce aby analiza tego zajmowała nam wiele czasu.

12. Okej to teraz wracamy do naszego `main.py` w serwisie i spróbujmy teraz stworzyć te API. Teraz bardzo istotne - napisze teraz pewną funkcję, która nie będzie dla Was jeszcze jasna. Ale chce żebyśmy stworzyli sobie coś działającego, na czym będziemy pracować i co będę omawiał, więc prośba, żeby po prostu napisać to co teraz ja napiszę, a potem się wszystko wyjaśni.
	1. Zdefiniujemy sobie taką funkcje jak:
	```python
	async def predict_decision(request: Request) -> JSONResponse:
	```
	Domyślam się, że dla w
