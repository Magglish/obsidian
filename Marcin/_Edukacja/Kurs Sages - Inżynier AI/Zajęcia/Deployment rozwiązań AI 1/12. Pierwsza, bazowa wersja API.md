# Budowa pierwszego, prostego API

1. Tak jak Wam mówiłem na początku, przez cały zjazd będę prowadził live coding wraz z omawianiem budowy API oraz problemami z którymi się spotkacie podczas implementowania API do serwisu z modelem MLowym i jak je rozwiązać.
2. API będzie powstawało w sposób iteracyjny, od bardzo prostych implementacji aż do czegoś bardziej zaawansowanego.
3. Zaczniemy sobie oczywiście od napisania czegoś minimalistycznego i jak sami zobaczycie FastAPI pozwala na zbudowanie API w kilku linijkach kodu, ale to oczywiście będzie początek.
4. Zacznijmy od tego aby w folderze `src` zrobić sobie folder `service`, w którym będziemy tworzyć sobie całą naszą implementację i plik `main.py`, który będzie stanowić główny core naszego API.
5. Zaimportujemy sobie podstawowe obiekty z FastAPI:
	1. główny obiekt FastAPI
	```python
	from fastapi import FastAPI  
	```
	2. Klase `Request`, który będzie na ten moment stanowił reprezentację naszego wejścia
	```python
	from fastapi.requests import Request
	```
	3. Klasy `JSONResponse` oraz `PlainTextResponse`, który będzie na ten moment stanowił reprezentację naszego wyjścia z API
	```python
	from fastapi.responses import JSONResponse, PlainTextResponse
	```
6. Następnie `uvicorn`, który jest środowiskiem uruchomieniowym API dla FastAPI, ale o `uvicornie` i jego działaniu powiemy sobie znacznie później, przy tematach zaawansowanych.
```python
import uvicorn
```
8. Dodatkowo `pandas` oraz `pathlib` który zaraz mi posłuży do wczytania modelu i pracy nad tym co otrzymam w API.
```python
import pandas as pd  
from pathlib import Path
```
9. Naszą abstrakcję modelu scoringowego
```python
from src.models.credit_score import CreditScoringModel
```
10. Następnie zainicjować musimy obiekt FastAPI
```python
app = FastAPI()
```
Sam ten obiekt ma w sobie wiele różnych ustawień, ale bęðziemy do nich sięgać w odpowiednich momentach. Wartości defaultowe są na ten moment wystarczające.
11. Następnie załadujemy sobie nasz model
```python
model = CreditScoringModel(path=Path("models/classifier.pkl"))
```
Krótkie omówienie tego czym ten CreditScoringModel jest:
1. Tak jak Wam mówiłem, inne rzeczy poza API, chce żeby były maksymalnie uproszczone. Nie chce żebyśmy teraz spędzali godziny nad jakąś skomplikowaną implementacją, bo chce żebyśmy skupili się w pełni na budowie API i jej problemów.  
2. Jeżeli będą jakieś dodatkowe rzeczy, które bezpośrednio w trakcie budowy API się nie tworzy, ale są jednak do API potrzebne - tak jak ta abstrackaj wokół modelu scoringowego - to one będą już przeze mnie zaimplementowane, tak żebyśmy zaoszczędzili sobie czasu i skupili się na ważniejszych rzeczach.
3. W dodatku mieliście wcześniej zajęcia z programowania obiektowego więc bez sensu żebym się powtarzał.
4. To co tu widzicie to prosta abstrakcja wokól modelu scoringowego, który ładuje model z pliku, który przechowywany jest w folderze `models` oraz ma opcję ustawienia punktu decyzyjnego, czy też odcięcia - czyli wnioski o kredyt, które charakteryzują się prawdopodobieństwem niespłacenia ich w ciągu ostatnich 12 miesięcu większym od 20% po prostu zostaną odrzucone. 
5. Mamy trzy proste metody:
	1. `predict_proba` - które zwracają nam prawdopodobieństwa dla każdego wniosku - lista floatów
	2. `predict_decision` - decyzje o zaakceptowaniu bądź odrzuceniu i jest to lista decyzji, gdzie decyzja to prosty Enum z definicją dwóch możliwych stanów
	3. `predict_risk_category` - oraz bardzo specyficzne dla problemu oceny wniosków - kategoria ryzyka od której w dużej mierze potem zależy marża banku. Metoda zwraca nam listę kategorii, która tez jest prostym Enumem - 4 kategorie określające górny próg prawdopodobieństwa.
6. Ta abstrakcja, którą tutaj widzicie posłuży nam przez cały zjazd i jak widzicie jest ona bardzo prosta i minimalistyczna bo nie chce aby analiza tego zajmowała nam wiele czasu.

12. Okej to teraz wracamy do naszego `main.py` w serwisie i spróbujmy teraz stworzyć te API. Teraz bardzo istotne - napisze teraz pewną funkcję, która nie będzie dla Was jeszcze jasna. Ale chce żebyśmy stworzyli sobie coś działającego, na czym będziemy pracować i co będę omawiał, więc prośba, żeby po prostu napisać to co teraz ja napiszę, a potem się wszystko wyjaśni.
	1. Zdefiniujemy sobie taką funkcje jak:
	```python
	async def predict_decision(request: Request) -> JSONResponse:
	```
	Domyślam się, że dla prawie wszystkich z Was słowo kluczowe `async` może być nowością, ale o `async` oraz o słówku `await`, które zaraz się pojawi będziemy rozmawiać na samym końcu zjazdu przy temacie asynchroniczności bo ten temat jest zaawansowany.
	Druga sprawa jest taka, że dodaje type hintowanie do inputów oraz outputów. Nie wiem czy było to omawiane na poprzednich zjazdach, ale tutaj w budowie API Typehintowanie jest wręcz WYMAGANE, podkreślam WYMAGANE, dlatego, że FastAPI pod spodem:
	1. Przekształca dane wysyłane do API na obiekt, który tutaj został określony
	2. Tworzy automatycznie dokumentację API, którą potem zobaczycie, na podstawie tego jakie są określane typy.  
 Następnie określmy sobie ciało funkcji:


1. 
```python
data = await request.json()
```
Drugie słówko `await`, może być nowością jak `async` ale tak jak mówiłem to później omówimy

2. Dane które przyjdą w `data` są słownikiem, który trzeba trochę przygotować zanim przekażemy do modelu oczekującym pd.DataFrame.
Trzeba je troche przekształcić.
```python
features = pd.DataFrame({key: [value] for key, value in data.items()})
```
Różnica jest taka, że teraz wartości w słowniku to po prostu lista jedno elementowa

3. Następnie wpuszczamy je do modelu
```python
decision = model.predict_decision(features)[0]
```

4. I zwracamy wynik w postaci JSONa
```python
return JSONResponse(decision.name)
```

5. Na końcu pozostaje nam zrobić ostatnią rzecz, co jest typowe dla FastAPI aby naszą funkcje udekorować jakiego rodzaju będzie to endpoint i jak się będzie nazywał

```python
@app.post("/predict_decision")
```
O rodzajach endpointów i komunikacji z nimi niedługo sobie powiemy

6. I dodamy sobie jeszcze jeden endpoint, który będzie niejako stanowił dla Nas informacje zwrotną, że nasze API działa i jest osiągalne:
```python
@app.get("/")
def welcome_page() -> PlainTextResponse:
    return PlainTextResponse("OK")
```
W przyszłości dowiecie się jak lepiej sprawdzić czy nasze API działa i można wysyłać do niego zapytania, na ten moment, na nasze potrzeby to co jest tutaj bedzie wystarczające.

8. Zostaje nam ostatni etap czyli uruchomienie naszego API:

```python
if __name__ == "__main__":
    uvicorn.run(
        app=app,
        host="0.0.0.0",
        port=8080,
        workers=1,
        reload=False,
    )
```

Czyli standardowa Pythonowa rzecz `if __name__ == "__main__":` - powiem Wam szczerze, że nigdy nie mogę tego zapamiętać :D

**Pyt:** Co to jest? 
**Odp:** W momencie kiedy uruchamiasz skrypt Pythonowy z poziomu konsoli `python src/service/main.py` to Python ustawia zmienną globalną `__name__` na wartość `__main__` i ten `if` zostanie wtedy uruchomiony - czyli tak jak chcemy. Natomiast gdybyś z innego skryptu chciał zaimportować coś z maina czyli `import src.service.main` to wtedy `__name__` dla tego modułu będzie miało wartość `src.service.main` jak sobie sprawdzić i w takiej sytuacji ten `if` ma wartość `False` i nie będzie uruchamiany. To jest takie zabezpieczenie się, żeby w momencie importowania funkcji z tego skryptu on się nie uruchomił, ale z drugiej strony robisz sobie z niego coś uruchomieniowego - tak jak My w tym przypadku. 

2. o tej wartości `0.0.0.0` w `host` powiemy sobie później, tak samo jeśli chodzi o `port`, temat `worker`-ów też omówimy sobie później, i wyłączymy `reload=False` tak żeby API nie resetowało nam się z każdą zmianą w skryptach (np. dodanie prostej spacji) - troche to wkurzające jest i może być obciążajace dla komputera, w zależności od tego jak wielki model mamy i jak wiele różnych obiektów API potrzebuje aby się uruchomić.

API możemy teraz uruchomić na dwa sposoby:
1. Albo z terminala: ustawiamy sobie ścieżke 
		export PYTHONPATH=\`pwd\`
	i uruchamiamy `python src/service/main.py`
2. Albo klikając RUN w Pycharmie czy VSCode

Jak widzicie mamy informacje o tym, że rozpoczął się proces o numerze jakimś tam - to też o tym powiemy sobie więcej później.
Info o czekaniu aż aplikacja wystartuje a potem, że wystartowała - to też bęðziemy wykorzystywać.
Oraz informacja o tym na jakim IP i co najważniejsze na jakim porcie działa nasze API - o tym też później.

Jak sobie teraz klikne w `http://0.0.0.0:8080` to powinienem przejsc do przegladarki wraz z tekstem `OK`, który został zdefiniowany w kodzie w `welcome_page`.

Teraz jak byśmy chcieli przejść sobie do `predict_decision` to otrzymujemy niezbyt precyzyjną informacje `{"detail":"Method Not Allowed"}`, ale to się wyjaśni potem jak przejdziemy do omówienia rodzajów endpointów.

A teraz przejdźmy sobie jeszcze do endpointów `/docs` oraz `/redoc` - jak widzice otrzymaliśmy na razie bardzo enigmatyczną dokumentację ona potem oczywiście będzie dalej rozwijana wraz z kolejnymi implementacjami. I jak się przekonacie, to będzie jeden z fajniejszych featerów FastAPI, czyli skupiacie się na implementacji w Pythonie, a cała magia dzieję się pod spodem - jeżeli będziecie kierować się odpowiednimi zasadami podczas implementowania API w FastAPI to on spokojnie wygeneruje dla Was całą dokumentację API.

Ok wróćmy teraz do tego `predict_decision` bo jak widzicie tutaj mamy informacje o `{"detail":"Method Not Allowed"}`. Tak na prawdę ten endpoint został zdefiniowaniu w taki sposób, że on oczekuje, że wyślemy mu jakieś dane, a nie że będziemy go przeglądać. Więc spróbujmy wysłać pierwszy request do niego.

Przejdźmy sobie do folderu `scripts` i w nim jak widzicie znajduje się skrypt `send_example_request.py`, który służyć nam będzie to testowania w trakcie dodawania naszych implementacji, czy to faktycznie działa. 

Sprawa tutaj jest bardzo prosta - mamy dane, które chcemy przekazać do modelu. I to co tutaj widzice to są zmienne, które wchodzą do modelu. I tak będzie we wszystkich API opartych o ML, które będziecie budować, po prostu wejściem do API będzie to co model wymaga, aby wykonać predykcję.

Następnie mamy kolejny słownik `headers` z informacją o `Content-Type` - o nagłówkach będziemy mówić więcej, ale na ten moment powiem tyle, że jest to pewna matadana, która przyjdzie razem z danymi w `data`, który mówi o tym, że `data` będzie w formacie JSON. A tak się skłąda, że pythonowy `dict` to praktycznie 1:1 z JSON-em, więc my Pythonowcy sprawę mamy uproszczoną w tym przypadku.
Następnie wyślemy te dane wykorzystujac bibliotekę `requests`, jak sama nazwa wskazuje, do wysyłania żądań, czyli `request` do naszego endpointu `predict_decision` i wyprintujemy sobie to co otrzymamy z API.

Podglądamy sobie printami w sumie dwie najważniejsze informacje, które jako użytkownik API będę podglądał:
1. `status_code` o których powiem więcej później, w tym przypadku wartość 200 oznacza, że wszystko zostało przetworzone poprawnie, bez żadnych problemów.
2. I dane zwrócone w formacie JSON, które metodą `.json()` sobie wyciągnąłem i jak widzicie w przypadku tej osoby decyzja jest `DECLINE` - czyli wniosek o kredyt został odrzucony.

Jeszcze jak spojrzymy sobie na terminal w którym działa nasze API to spojrzymy, że dostaliśmy kilka informacji o tym co się działo. Mamy jakieś GETy i POSTy na konkretne endpointy, które sprawdzaliśmy i do których wysyłaliśmy dane. Więc FastAPI dostarcza jakiegoś podstawowego logowania tego co się w API dzieje, ale jest to słabe i niewystarczające - o logowaniu powiemy sobie więcej później.

Jeszcze jedna rzecz - jak widzicie mamy plik `Makefile`, który ułatwi nam znacznie korzystanie z naszego API. Mamy tam metode `request` oraz `api` a wywołanie ich to po prostu `make request` albo `make api`. Proponuje używanie tych skrótów bo to będzie po prostu szybsze dla każdego z nas. A logika Makefile jak widzicie jest banalna, zapisuje sobie nazwe kroku i to co ma zostać wywołane gdy go uruchomie. O samym Makefile będziemy mówić więcej na 4 zjeździe, bo można zrobić z niego naprawdę świetny użytek i zautomatyzować i zintegrować ze sobą wiele rzeczy na raz.

Ok - jak widzicie zbudowanie pierwszego API, jakiegokolwiek, jest banalne i zajmuje kilka linijek kodu. Ale domyślam się, że wiele rzeczy jest tutaj jeszcze nie zrozumiałych, bo to jest Wasz pierwszy kontakt z tym zagadnieniem. Więc przejdziemy sobie teraz do omawiania po kolei co tutaj się zadziało i usprawniania naszego API krok po kroku.

Ale zanim przejdziemy dalej to jeszcze jedna rzecz - w Data Science będziecie przyzwyczajeni do Notebooków, które są interaktywne. Można sobie podejrzeć czym jest dany obiekt, manipulować nim itd. itd. Jest to bardzo fajne i wygodne. Tutaj natomiast tego nie ma. Pytanie powstaje jak można sobie ułatwić zadanie w projektowaniu API? Jeżeli jeszcze nie korzystaliście, to polecam Wam korzystać z debugera w tym przypadku.

W PyCharmie możemy ustawić sobie tak zwane breakpointy, które mają za zadanie zatrzymać kod w danym miejscu. Ustawmy sobie na linie gdzie jest decyzja z modelu..
Następnie te API musimy uruchomić w trybie Debugera - niestety jeżeli uruchomimy to z poziomu terminala, to uruchomi się taki ubogi pythonowy `pdb`, który jest kiepski. Jeżeli uruchomimy to z IDE to dostaniemy coś znacznie lepszego, więc w tym przypadku polecam kliknąć tę strzałke oprócż `if __name__ == "__main__":` i wybrać `Debug 'main'`.
Powinno sie uruchmić tak samo jak poprzednio.

Wykonajmy teraz requesta korzystając z `make request`. Jak widzicie, kod zatrzymał się przed danym miejscem. Jak widzicie PyCharm podpowiada mi w ekranie jakie wartości przyjmują dane obiekty.

W Debugerze mam "Console" i mogę działać. W "Debugger" mam podgląd obiektów i tego z czego się składają. W ten sposób możemy otrzymać tą interaktywnośc jaka jest w Notebooku i podejrzeć to jak te API działa i co konkretne kroki robią. Jak już chcemy, żeby API działało całe, to pamiętajmy o tym, żeby tego breakpointa odchaczyć. Jeżeli zaznaczanie breakpointa w IDE nie zadziała, to można wprost wpisać frazę `breakpoint()` w kodzie i to zadziała tak samo.

Zanim przejdziemy dalej - czy macie jakieś pytania do tej części?

## Cały skrypt

```python
from fastapi import FastAPI  
from fastapi.requests import Request  
from fastapi.responses import JSONResponse, PlainTextResponse  
  
import uvicorn  
  
import pandas as pd  
from pathlib import Path  
  
from src.models.credit_score import CreditScoringModel  
  
  
app = FastAPI()  
  
model = CreditScoringModel(path=Path("models/classifier.pkl"))  
  
  
@app.post("/predict_decision")  
async def predict_decision(request: Request) -> JSONResponse:  
    data = await request.json()  
    features = pd.DataFrame({key: [value] for key, value in data.items()})  
    decision = model.predict_decision(features)[0]  
    return JSONResponse(decision.name)  
  
  
@app.get("/")  
def welcome_page() -> PlainTextResponse:  
    return PlainTextResponse("OK")  
  
  
if __name__ == "__main__":  
    uvicorn.run(  
        app=app,  
        host="0.0.0.0",  
        port=8080,  
        workers=1,  
        reload=False,  
    )
```