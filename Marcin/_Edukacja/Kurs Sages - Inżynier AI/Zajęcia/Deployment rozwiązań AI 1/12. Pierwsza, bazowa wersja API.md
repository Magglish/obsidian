# Budowa pierwszego, prostego API

1. Tak jak Wam mówiłem na początku, przez cały zjazd będę prowadził live coding wraz z omawianiem budowy API, problemami z którymi się spotkacie podczas implementowania API do serwisu z modelem MLowym i jak je rozwiązać.
2. API będzie powstawało w sposób iteracyjny, od bardzo prostych implementacji aż do czegoś bardziej zaawansowanego.
3. Zaczniemy sobie oczywiście od napisania czegoś minimalistycznego i jak sami zobaczycie FastAPI pozwala na zbudowanie API w kilku linijkach kodu, ale to oczywiście będzie początek.
4. Zacznijmy od tego aby w folderze `src` zrobić sobie folder `service`, w którym będziemy tworzyć sobie całą naszą implementację i plik `main.py`, który będzie stanowić główny core naszego API.
5. Zaimportujemy sobie podstawowe obiekty z FastAPI:
	1. główny obiekt FastAPI
	```python
	from fastapi import FastAPI  
	```
	2. Klase `Request`, który będzie na ten moment stanowił reprezentację naszego wejścia
	```python
	from fastapi.requests import Request
	```
	3. Klase `JSONResponse`, który będzie na ten moment stanowił reprezentację naszego wyjścia z API
	```python
	from fastapi.responses import JSONResponse
	```
6. Następnie `uvicorn`, który jest środowiskiem uruchomieniowym API dla FastAPI, ale o `uvicornie` i jego działaniu powiemy sobie znacznie później, przy tematach zaawansowanych.
```python
import uvicorn
```
8. Dodatkowo `pandas` oraz `pathlib` który zaraz mi posłuży do wczytania modelu i pracy nad tym co otrzymam w API.
```python
import pandas as pd  
from pathlib import Path
```
9. Naszą abstrakcję modelu scoringowego
```python
from src.models.credit_score import CreditScoringModel
```
10. Następnie zainicjować musimy obiekt FastAPI
```python
app = FastAPI()
```
Sam ten obiekt ma w sobie wiele różnych ustawień, ale bęðziemy do nich sięgać w odpowiednich momentach. Wartości defaultowe są na ten moment wystarczające.
11. Następnie załadujemy sobie nasz model
```python
model = CreditScoringModel(path=Path("models/classifier.pkl"))
```
Krótkie omówienie tego czym ten CreditScoringModel jest:
1. Tak jak Wam mówiłem, inne rzeczy poza API, chce żeby były maksymalnie uproszczone. Nie chce żebyśmy teraz spędzali godziny nad jakąś skomplikowaną implementacją, bo chce żebyśmy skupili się w pełni na budowie API i jej problemów.  
2. Jeżeli będą jakieś dodatkowe rzeczy, które bezpośrednio w trakcie budowy API się nie tworzy, ale są jednak do API potrzebne - tak jak ta abstrackaj wokół modelu scoringowego - to one będą już przeze mnie zaimplementowane, tak żebyśmy zaoszczędzili sobie czasu i skupili się na ważniejszych rzeczach.
3. W dodatku mieliście wcześniej zajęcia z programowania obiektowego więc bez sensu żebym się powtarzał.
4. To co tu widzicie to prosta abstrakcja wokól modelu scoringowego, który ładuje model z pliku, który przechowywany jest w folderze `models` oraz ma opcję ustawienia punktu decyzyjnego, czy też odcięcia - czyli wnioski o kredyt, które charakteryzują się prawdopodobieństwem niespłacenia ich w ciągu ostatnich 12 miesięcu większym od 20% po prostu zostaną odrzucone. 
5. Mamy trzy proste metody:
	1. `predict_proba` - które zwracają nam prawdopodobieństwa dla każdego wniosku - lista floatów
	2. `predict_decision` - decyzje o zaakceptowaniu bądź odrzuceniu i jest to lista decyzji, gdzie decyzja to prosty Enum z definicją dwóch możliwych stanów
	3. `predict_risk_category` - oraz bardzo specyficzne dla problemu oceny wniosków - kategoria ryzyka od której w dużej mierze potem zależy marża banku. Metoda zwraca nam listę kategorii, która tez jest prostym Enumem - 4 kategorie określające górny próg prawdopodobieństwa.
6. Ta abstrakcja, którą tutaj widzicie posłuży nam przez cały zjazd i jak widzicie jest ona bardzo prosta i minimalistyczna bo nie chce aby analiza tego zajmowała nam wiele czasu.

12. Okej to teraz wracamy do naszego `main.py` w serwisie i spróbujmy teraz stworzyć te API. Teraz bardzo istotne - napisze teraz pewną funkcję, która nie będzie dla Was jeszcze jasna. Ale chce żebyśmy stworzyli sobie coś działającego, na czym będziemy pracować i co będę omawiał, więc prośba, żeby po prostu napisać to co teraz ja napiszę, a potem się wszystko wyjaśni.
	1. Zdefiniujemy sobie taką funkcje jak:
	```python
	async def predict_decision(request: Request) -> JSONResponse:
	```
	Domyślam się, że dla prawie wszystkich z Was słowo kluczowe `async` może być nowością, ale o `async` oraz o słówku `await`, które zaraz się pojawi będziemy rozmawiać na samym końcu zjazdu przy temacie asynchroniczności bo ten temat jest zaawansowany.
	Druga sprawa jest taka, że dodaje type hintowanie do inputów oraz outputów. Nie wiem czy było to omawiane na poprzednich zjazdach, ale tutaj w budowie API Typehintowanie jest wręcz WYMAGANE, podkreślam WYMAGANE, dlatego, że FastAPI pod spodem:
	1. Przekształca dane wysyłane do API na obiekt, który tutaj został określony
	2. Tworzy automatycznie dokumentację na podstawie tego jakie są typy.  
 Następnie określmy sobie ciało funkcji:


1. 
```python
data = await request.json()
```
Drugie słówko `await`, może być nowością jak `async` ale tak jak mówiłem to później omówimy

2. Dane które przyjdą w `data` są słownikiem, który trzeba trochę przygotować zanim przekażemy do modelu oczekującym pd.DataFrame.
Trzeba je troche przekształcić.
```python
features = pd.DataFrame({key: [value] for key, value in data.items()})
```
Różnica jest taka, że teraz wartości w słowniku to po prostu lista jedno elementowa

3. Następnie wpuszczamy je do modelu
```python
decision = model.predict_decision(features)[0]
```

4. I zwracamy wynik w postaci JSONa
```python
return JSONResponse(decision.name)
```

5. Na końcu pozostaje nam zrobić ostatnią rzecz, co jest typowe dla FastAPI aby naszą funkcje udekorować jakiego rodzaju będzie to endpoint i jak się będzie nazywał

```python
@app.post("/predict_decision")
```
O rodzajach endpointów i komunikacji z nimi niedługo sobie powiemy

6. Zostaje nam ostatni etap czyli uruchomienie naszego API:

```python
if __name__ == "__main__":
    uvicorn.run(
        app=app,
        host="0.0.0.0",
        port=8080,
        workers=1,
        reload=False,
    )
```

Czyli standardowa Pythonowa rzecz `if __name__ == "__main__":` - powiem Wam szczerze, że nigdy nie mogę tego zapamiętać :D

**Pyt:** Co to jest? 
**Odp:** W momencie kiedy uruchamiasz skrypt Pythonowy z poziomu konsoli `python src/service/main.py` to Python ustawia zmienną globalną `__name__` na wartość `__main__` i ten `if` zostanie wtedy uruchomiony - czyli tak jak chcemy. Natomiast gdybyś z innego skryptu chciał zaimportować coś z maina czyli `import src.service.main` to wtedy `__name__` dla tego modułu będzie miało wartość `src.service.main` jak sobie sprawdzić i w takiej sytuacji ten `if` ma wartość `False` i nie będzie uruchamiany. To jest takie zabezpieczenie się, żeby w momencie importowania funkcji z tego skryptu on się nie uruchomił, ale z drugiej strony robisz sobie z niego coś uruchomieniowego - tak jak My w tym przypadku. 

2. o ten wartości `0.0.0.0` w `host` powiemy sobie później, tak samo jeśli chodzi o `port`, temat `worker`-ów też omówimy sobie później, i wyłączymy `reload=False` tak żeby API nie resetowało nam się z każdą dodaną spacją do skryptów - troche to wkurzające jest i może być obciążajace dla komputera, w zależności od tego jak wielki model mamy i jak wiele różnych obiektów on potrzebuje żeby go zainicjować.

API możemy teraz uruchomić na dwa sposoby:
1. Albo z terminala: ustawiamy sobie ścieżke 
		export PYTHONPATH=\`pwd\`
	i uruchamiamy `python src/service/main.py`
2. Albo klikając RUN w Pycharmie czy VSCode

## Cały skrypt

```python
from fastapi import FastAPI  
from fastapi.requests import Request  
from fastapi.responses import JSONResponse  
  
import uvicorn  
  
import pandas as pd  
from pathlib import Path  
  
from src.models.credit_score import CreditScoringModel  
  
  
app = FastAPI()  
  
model = CreditScoringModel(path=Path("models/classifier.pkl"))  
  
  
@app.post("/predict_decision")  
async def predict_decision(request: Request) -> JSONResponse:  
    data = await request.json()  
    features = pd.DataFrame({key: [value] for key, value in data.items()})  
    decision = model.predict_decision(features)[0]  
    return JSONResponse(decision.name)  
  
  
if __name__ == "__main__":  
    uvicorn.run(  
        app=app,  
        host="0.0.0.0",  
        port=8080,  
        workers=1,  
        reload=False,  
    )
```