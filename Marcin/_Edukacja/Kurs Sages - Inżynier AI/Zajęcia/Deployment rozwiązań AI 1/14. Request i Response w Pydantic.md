# Request i Response w Pydantic

1. Ok zatem wiemy jakie są rodzaje endpointów i do czego one służą. Rozpracujmy sobie teraz środek endpointa `predict_decision` czyli naszą funkcję `async def predict_decision`. Ustawmy sobie breakpoint np. na moment gdzie jest generowana decyzja z modelu. Uruchommy nasze API w opcji debugera, czyli obok `if __name__ == "__main__"` kliknijmy `Run in debugger` i wyślijmy zapytanie poprzez `make request`.
2. Debuger zatrzymał nam działanie kodu i teraz spójrzmy co mamy. Tak jak Wam powiedziałem na początku, FastAPI działa tak, że zapytanie/żądanie, czyli request który otrzymuje odpowiednio przetwarza na obiekt, który został określony w type hincie. W tym przypadku `request` jest typu `Request` - w ten sposób otrzymujemy surowe żądanie, które wysłaliśmy do API. I jeżeli spojrzymy sobie w to co otrzymaliśmy to jak widzicie jest tutaj cała masa informacji i różnych obiektów. 
	1. Jest obiekt `app` - to jest ciekawostka, czyli w ten obiekt, który zdefiniowaliśmy u góry `app` jest też zawarty w requeście, ale to jest specyfika działania FastAPI - później to wykorzystamy, ale nie teraz. 
	2. Mamy bazowe informacje o `base_url` gdzie ten request został wysłany. 
	3. `client` czyli skąd został wysłany
	4. `cookies` czyli ciasteczka
	5. `headers` czyli nagłówki, jak widzicie jest ich więcej niż zdefiniowaliśmy w naszym `send_example_request.py` i jeszcze wiele innych obiektów. W tej chwili nie będę wchodził w szczegóły, bo wszystkie te informacje jakie są w żądaniu warto jest znać, ale to będzie omawiane później, nie teraz. To co teraz chce pokazać to to, że tych informacji jest tutaj bardzo dużo. Ale my de facto do wykonania predykcji potrzebujemy tylko i wyłącznie danych do modelu - nic więcej. Więc cały szereg tych informacji jest po prostu nam niepotrzebny. W dodatku zobaczcie, że muszę te dane wyciągnąć korzystając ze słowa `await`, które zapewne widzicie po raz pierwszy, potem zamienić słownik na `pd.DataFrame`. Pytanie czy można to uprościć? 
3. I tutaj na pomoc przychodzi biblioteka `pydantic`, na której FastAPI w pełni się opiera i tiangolo, czyli twórca FastAPI, jest w bardzo dobrych relacjach z twórcami `pydantic` i wspierają się w rozwijaniu tych bibliotek. `pydantic` to bilbioteka, która nie tylko jest używana w FastAPI, ale również [poza](https://docs.pydantic.dev/latest/why/#ecosystem), ponieważ pozwala na definiowanie bardzo rozbudowanych i zaawansowanych customowych struktur danych - innymi słowy to jest taki `dataclass`, ale [na sterydach](https://docs.pydantic.dev/latest/#pydantic-examples). 
4. Ja na tym kursie nie będę omawiał całego pydantica bo biblioteka dostarcza naprawdę ogromnych możliwości i na omówienie tego co można w niej zrobić ze strukturami danych możnaby poświęcić cały dzień. Natomiast co jest podstawowym wyróżnikiem jej i powoduje, że jest lepsza niż pythonowa, wbudowana biblioteka `dataclasses`? To, że w pełni opiera się na type hintach. Co oznacza w pełni? Że automatycznie te struktury danych mają zaimplementowaną w sobie walidacje parametrów wejścia. Jeżeli my zdefiniujemy sobie, że nasze `id` ma być `int` a podamy mu `stringa`, tak jak w tym przykładzie, automatycznie otrzymuje informacje w postaci błędu, że wartość `id` powinna być `int`-em a nie `string`. Plusem jest też to, że jeżeli zdefiniujemy sobie swoje własne customowe typy, to też Pydantic jest w stanie zwalidować to co podamy do tej klasy - za chwilę się o tym sami przekonacie. W dodatku My możemy definiować swoje własne customowe [walidacje wejścia](https://docs.pydantic.dev/1.10/usage/validators/). Tak jak widzimy w tym przykładzie, sam type hint jest nie wystarczający, możemy chcieć zwalidować jeszcze dodatkowo w jakiś sposób `name`, `password` i `username`. Ok. Wiemy mniej więcej czym pydantic jest - mówiąc krótko: są to dataclassy na sterydach. Zostawiam Wam, jako forma ćwiczeń/zadania w domu żebyście sami zgłębili tą bibliotekę w wolnej chwili i polecam korzystać z niej nie tylko podczas budowy API, ale również na codzień, kiedy spotkacie się z sytuacją, że lepiej będzie Wam coś zaimplementować, jeśli stworzycie customową strukture danych - wtedy polecam siegnąc nie po `dataclass` a po `pydantic`-a.
5. Ok wróćmy do naszego kodu i spróbujmy to zaimplementować. Wyłączamy breakpointa i zatrzymujemy API. Teraz to co będziemy robić to skorzystamy z pydantica, żeby pozbyć się tego surowego `Requesta` i zamienić na customową strukturę danych. Żeby sobie zączać strukturyzować nasz kod, chce żebyśmy stworzyli sobie nowy folder o nazwie `schemas`