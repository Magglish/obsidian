# Request i Response w Pydantic

1. Ok zatem wiemy jakie są rodzaje endpointów i do czego one służą. Rozpracujmy sobie teraz środek endpointa `predict_decision` czyli naszą funkcję `async def predict_decision`. Ustawmy sobie breakpoint np. na moment gdzie jest generowana decyzja z modelu. Uruchommy nasze API w opcji debugera, czyli obok `if __name__ == "__main__"` kliknijmy `Run in debugger` i wyślijmy zapytanie poprzez `make request`.
2. Debuger zatrzymał nam działanie kodu i teraz spójrzmy co mamy. Tak jak Wam powiedziałem na początku, FastAPI działa tak, że zapytanie/żądanie, czyli request który otrzymuje odpowiednio przetwarza na obiekt, który został określony w type hincie. W tym przypadku `request` jest typu `Request` - w ten sposób otrzymujemy surowe żądanie, które wysłaliśmy do API. I jeżeli spojrzymy sobie w to co otrzymaliśmy to jak widzicie jest tutaj cała masa informacji i różnych obiektów. 
	1. Jest obiekt `app` - to jest ciekawostka, czyli w ten obiekt, który zdefiniowaliśmy u góry `app` jest też zawarty w requeście, ale to jest specyfika działania FastAPI - później to wykorzystamy, ale nie teraz. 
	2. Mamy bazowe informacje o `base_url` gdzie ten request został wysłany. 
	3. `client` czyli skąd został wysłany
	4. `cookies` czyli ciasteczka
	5. `headers` czyli nagłówki, jak widzicie jest ich więcej niż zdefiniowaliśmy w naszym `send_example_request.py` i jeszcze wiele innych obiektów. W tej chwili nie będę wchodził w szczegóły, bo wszystkie te informacje jakie są w żądaniu warto jest znać, ale to będzie omawiane później, nie teraz. To co teraz chce pokazać to to, że tych informacji jest tutaj bardzo dużo. Ale my de facto do wykonania predykcji potrzebujemy tylko i wyłącznie danych do modelu - nic więcej. Więc cały szereg tych informacji jest po prostu nam niepotrzebny. W dodatku zobaczcie, że muszę te dane wyciągnąć korzystając ze słowa `await`, które zapewne widzicie po raz pierwszy, potem zamienić słownik na `pd.DataFrame`. Pytanie czy można to uprościć? 
3. I tutaj na pomoc przychodzi biblioteka `pydantic`, na której FastAPI w pełni się opiera i tiangolo, czyli twórca FastAPI, jest w bardzo dobrych relacjach z twórcami `pydantic` i wspierają się w rozwijaniu tych bibliotek. `pydantic` to bilbioteka, która nie tylko jest używana w FastAPI, ale również [poza](https://docs.pydantic.dev/latest/why/#ecosystem), ponieważ pozwala na definiowanie bardzo rozbudowanych i zaawansowanych customowych struktur danych - innymi słowy to jest taki `dataclass`, ale [na sterydach](https://docs.pydantic.dev/latest/#pydantic-examples). 
4. Ja na tym kursie nie będę omawiał całego pydantica bo biblioteka dostarcza naprawdę ogromnych możliwości i na omówienie tego co można w niej zrobić ze strukturami danych możnaby poświęcić cały dzień. Natomiast co jest podstawowym wyróżnikiem jej i powoduje, że jest lepsza niż pythonowa, wbudowana biblioteka `dataclasses`? To, że w pełni opiera się na type hintach. Co oznacza w pełni? Że automatycznie te struktury danych mają zaimplementowaną w sobie walidacje parametrów wejścia. Jeżeli my zdefiniujemy sobie, że nasze `id` ma być `int` a podamy mu `stringa`, tak jak w tym przykładzie, automatycznie otrzymuje informacje w postaci błędu, że wartość `id` powinna być `int`-em a nie `string`. Plusem jest też to, że jeżeli zdefiniujemy sobie swoje własne customowe typy, to też Pydantic jest w stanie zwalidować to co podamy do tej klasy - za chwilę się o tym sami przekonacie. W dodatku My możemy definiować swoje własne customowe [walidacje wejścia](https://docs.pydantic.dev/1.10/usage/validators/). 