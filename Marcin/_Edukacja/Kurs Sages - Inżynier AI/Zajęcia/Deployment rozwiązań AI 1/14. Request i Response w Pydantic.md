# Request i Response w Pydantic

1. Ok zatem wiemy jakie są rodzaje endpointów i do czego one służą. Rozpracujmy sobie teraz środek endpointa `predict_decision` czyli naszą funkcję `async def predict_decision`. Ustawmy sobie breakpoint np. na moment gdzie jest generowana decyzja z modelu. Uruchommy nasze API w opcji debugera, czyli obok `if __name__ == "__main__"` kliknijmy `Run in debugger` i wyślijmy zapytanie poprzez `make request`.
2. Debuger zatrzymał nam działanie kodu i teraz spójrzmy co mamy. Tak jak Wam powiedziałem na początku, FastAPI działa tak, że zapytanie/żądanie, czyli request który otrzymuje odpowiednio przetwarza na obiekt, który został określony w type hincie. W tym przypadku `request` jest typu `Request` - w ten sposób otrzymujemy surowe żądanie, które wysłaliśmy do API. I jeżeli spojrzymy sobie w to co otrzymaliśmy to jak widzicie jest tutaj cała masa informacji i różnych obiektów. 
	1. Jest obiekt `app` - to jest ciekawostka, czyli w ten obiekt, który zdefiniowaliśmy u góry `app` jest też zawarty w requeście, ale to jest specyfika działania FastAPI - później to wykorzystamy, ale nie teraz. 
	2. Mamy bazowe informacje o `base_url` gdzie ten request został wysłany. 
	3. `client` czyli skąd został wysłany
	4. `cookies` czyli ciasteczka
	5. `headers` czyli nagłówki, jak widzicie jest ich więcej niż zdefiniowaliśmy w naszym `send_example_request.py` i jeszcze wiele innych obiektów. W tej chwili nie będę wchodził w szczegóły, bo wszystkie te informacje jakie są w żądaniu warto jest znać, ale to będzie omawiane później, nie teraz. To co teraz chce pokazać to to, że tych informacji jest tutaj bardzo dużo. Ale my de facto do wykonania predykcji potrzebujemy tylko i wyłącznie danych do modelu - nic więcej. Więc cały szereg tych informacji jest po prostu nam niepotrzebny. W dodatku zobaczcie, że muszę te dane wyciągnąć korzystając ze słowa `await`, które zapewne widzicie po raz pierwszy, potem zamienić słownik na `pd.DataFrame`. Pytanie czy można to uprościć? 
3. I tutaj na pomoc przychodzi biblioteka `pydantic`, na której FastAPI w pełni się opiera i tiangolo, czyli twórca FastAPI, jest w bardzo dobrych relacjach z twórcami `pydantic` i wspierają się w rozwijaniu tych bibliotek. `pydantic` to bilbioteka, która nie tylko jest używana w FastAPI, ale również [poza](https://docs.pydantic.dev/latest/why/#ecosystem), ponieważ pozwala na definiowanie bardzo rozbudowanych i zaawansowanych customowych struktur danych - innymi słowy to jest taki `dataclass`, ale [na sterydach](https://docs.pydantic.dev/latest/#pydantic-examples). 
4. Ja na tym kursie nie będę omawiał całego pydantica bo biblioteka dostarcza naprawdę ogromnych możliwości i na omówienie tego co można w niej zrobić ze strukturami danych możnaby poświęcić cały dzień. Natomiast co jest podstawowym wyróżnikiem jej i powoduje, że jest lepsza niż pythonowa, wbudowana biblioteka `dataclasses`? To, że w pełni opiera się na type hintach. Co oznacza w pełni? Że automatycznie te struktury danych mają zaimplementowaną w sobie walidacje parametrów wejścia. Jeżeli my zdefiniujemy sobie, że nasze `id` ma być `int` a podamy mu `stringa`, tak jak w tym przykładzie, automatycznie otrzymuje informacje w postaci błędu, że wartość `id` powinna być `int`-em a nie `string`. Plusem jest też to, że jeżeli zdefiniujemy sobie swoje własne customowe typy, to też Pydantic jest w stanie zwalidować to co podamy do tej klasy - za chwilę się o tym sami przekonacie. W dodatku My możemy definiować swoje własne customowe [walidacje wejścia](https://docs.pydantic.dev/1.10/usage/validators/). Tak jak widzimy w tym przykładzie, sam type hint jest nie wystarczający, możemy chcieć zwalidować jeszcze dodatkowo w jakiś sposób `name`, `password` i `username`. Ok. Wiemy mniej więcej czym pydantic jest - mówiąc krótko: są to dataclassy na sterydach. Zostawiam Wam, jako forma ćwiczeń/zadania w domu żebyście sami zgłębili tą bibliotekę w wolnej chwili i polecam korzystać z niej nie tylko podczas budowy API, ale również na codzień, kiedy spotkacie się z sytuacją, że lepiej będzie Wam coś zaimplementować, jeśli stworzycie customową strukture danych - wtedy polecam siegnąc nie po `dataclass` a po `pydantic`-a.
   Jeszcze bardzo ważna rzecz - ten kurs został przygotowany w oparciu o Pydantic v1. Nie korzystam z wersji 2 - u góry na stronie można wybrać wersję. Różnice pomiędzy Pydantic v2 a v1 są ogromne. Pydantic v1 bedzie się trzymał bardzo długo zanim całkowicie. To troche tak jak sytuacja z Pythonem 2.7 i Python 3. Python 2.7 był utrzymywany jeszcze przez 10 lat, zanim przestali go wspierać. Z biblioteką pydantic oczywiście tak nie będzie, ale chodzi mi o to, że jest mnóstwo zmian niekompatybilnych wstecz. DLaczego kurs został przygotowany pod werzje v1 a nie v2? Z kilku powodów:
   1) Pydantic v2 ma mniej niż rok - cały czas są robione bugfixy i wypuszczane nowe wersje. V2 nie jest jeszcze stabilna na tyle aby móc w pełni oprzeć swoją produkcyjne API na nim. Ja generalnie przyjmuje zasadę, że jeżeli wprowadzana jest nowa wersja apki, ale nie drobna zmiana tylko duża. Jak np. przejście z Tensorflow 1 na 2, Pytorch z 1 na 2 zmigrował, czy właśnie pydantic z v1 na v2 - i widze w release notesach, ze zmiany są ogromne i niekompatybilne wstecz, to po prostu czekam minimum 1 rok żeby nowa wersja się "wygrzała" - naprawione zostały błędy, ludzie nauczyli się z tego korzystać więc już pewne problemy napotkane jako pierwsze zostaną rozwiązane. Dopiero po roku czasu rozważam, czy przechodze na nową wersję czy nie. W pydanticu v2 np. cała ta [walidacja](https://docs.pydantic.dev/1.10/usage/validators/) parametrów się zmieniła - kod z v1 w ogóle nie działa v2.
   2) Drugi argument jest taki, że mnóstwo tutoriali w sieci, czy rozwiązań na stackoverlow są na pydantic v1. V2 jest jeszcze młoda i nie ma za dużo rozwiązań i tutoriali jak coś zrobić. Więc ogólnie jak bedziecie szukać czegoś w sieci trzeba zwrócić uwagę na to czy kod jest na v1 czy na v2.
   3) I trzeci argument - jeżeli spojrzymy sobie na [biblioteki, które korzystają z pydantica](https://docs.pydantic.dev/latest/why/#ecosystem). Jest ich bardzo dużo. Jak wygląda ich migracja na v2? Nie wiem. Wiem tylko, że FastAPI od wersji `0.100.0` wspiera Pydantica v2 - ma pracujemy na wersji `0.99.1` czyli przed migracją na v2. Natomiast jak pozostałe bilbioteki? Kiedy np. `transformers` przejdzie na v2? Nie mam pojęcia. To może zająć im długo, tym bardziej, że jest to biblioteka z open sourceowymi modelami, transformerami stworzonymi w Pytorchu. Chodzi o to, że możecie mieć konflikty w repo, jeżeli chcecie korzytać z Pydantica v2, a biblioteki które macie w repo korzystają jeszcze z v1. 
      Podsumowując:  dla własnej wygody i bezpieczeńśtwa, trzymajmy się na razie z dala od v2 i czekajmy aż to się przyjmie, przetrawi i większość bibliotek, które z tego korzystają zmigrują swój codebase na v2.
1. Ok wróćmy do naszego kodu i spróbujmy to zaimplementować. Wyłączamy breakpointa i zatrzymujemy API. Teraz to co będziemy robić to skorzystamy z pydantica, żeby pozbyć się tego surowego `Requesta` i zamienić na customową strukturę danych. Żeby sobie zączać strukturyzować nasz kod, chce żebyśmy stworzyli sobie nowy folder o nazwie `schemas`. A w nim dwa skrypty: `requests.py` oraz `responses.py`