# Request i Response w Pydantic

1. Ok zatem wiemy jakie są rodzaje endpointów i do czego one służą. Rozpracujmy sobie teraz środek endpointa `predict_decision` czyli naszą funkcję `async def predict_decision`. Ustawmy sobie breakpoint np. na moment gdzie jest generowana decyzja z modelu. Uruchommy nasze API w opcji debugera, czyli obok `if __name__ == "__main__"` kliknijmy `Run in debugger` i wyślijmy zapytanie poprzez `make request`.
2. Debuger zatrzymał nam działanie kodu i teraz spójrzmy co mamy. Tak jak Wam powiedziałem na początku, FastAPI działa tak, że zapytanie/żądanie, czyli request który otrzymuje odpowiednio przetwarza na obiekt, który został określony w type hincie. W tym przypadku `request` jest typu `Request` - w ten sposób otrzymujemy surowe żądanie, które wysłaliśmy do API. I jeżeli spojrzymy sobie w to co otrzymaliśmy to jak widzicie jest tutaj cała masa informacji i różnych obiektów. 
	1. Jest obiekt `app` - to jest ciekawostka, czyli w ten obiekt, który zdefiniowaliśmy u góry `app` jest też zawarty w requeście, ale to jest specyfika działania FastAPI - później to wykorzystamy, ale nie teraz. 
	2. Mamy bazowe informacje o `base_url` gdzie ten request został wysłany. 
	3. `client` czyli skąd został wysłany
	4. `cookies` czyli ciasteczka
	5. `headers` czyli nagłówki, jak widzicie jest ich więcej niż zdefiniowaliśmy w naszym `send_example_request.py` i jeszcze wiele innych obiektów. W tej chwili nie będę wchodził w szczegóły, bo 