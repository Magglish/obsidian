# REST API

1. Druga najważniejsza część do omówienia to czym jest REST API? 
2. Zanim przejdziemy do REST, wróćmy jeszcze raz do pojęcia API. Wcześniej omawiałem czym jest API, ale omawiałem to z takiego wyższego poziomu - API jako element systemu, API jako kontrakt/umowa, API jako produkt. Teraz przy omawianiu REST API musimy sobie zejść na niższy poziom, techniczny i dopełnić tą definicję API.
3. Zacznijmy od literki "I" - czyli Interface. *Interfejs* to nic innego jak pewna abstrakcja/pewna warstwa, która istnieje pomiędzy nami, czyli użytkownikami, a rzeczą/obiektem/serwerem, w zależności od kontekstu, z którego chcielibyśmy korzystać. Z *intefejsem* spotykacie sie cały czas. Takim przykładem *interfajsu* może być kierownica, pedały gazu w aucie i dźwignia zmiany biegów, które pozwalają Wam na sterowanie autem.
4. Natomiast "API" czyli Application Programming Interface, to jest nasz sposób na używanie tego co zostało zaimplementowane w komputerach. Z API też się spotykacie cały czas - klasę którą zdefiniowałem sobie jako `CreditScoringModel` też można określić jako API - interface, który pozwala mi - użytkownikowi - korzystać z logiki działania modelu i generowanie predykcji poprzez użycie odpowiednich metod `predict_proba`, `predict_decision` i `predict_risk_category`. Tak samo `from sklearn.linear_model import LogisticRegression` jest też pewnym API - ja mogę skorzystać z implementacji, logiki stworzonej przez developerów `sklearn` poprzez importowanie odpowienich klas z ich bilbioteki i wywoływanie odpowienich metod. To wszystko co tutaj omówiłem możemy określić jako API.
5. Aczkolwiek w praktyce rozmawiając o API, mówiąc o API, czy w ogóle myśląc o API, zawsze bardziej odnosimy się do pewnego serwisu dostępnego w sieci. Głównie przez to, że w ogóle jak się szuka infromacji czym jest API to najczęściej API wytłumaczone jest jako pewien serwis i najczęściej podawany przykład serwisu typu CRUD - czyli Create, Read, Update, Delete i w ramach tego samego artykułu/blogu od razu jest kontynuacja do pojęcia REST. Dlatego pojęcie API jest bardzo mocno osadzone w kontekście serwisów, ale jego pojęcie jest bardzo szerokie.
6. Ok wiemy czym jest API. Natomiast to czego my uczymy się to projektowanie REST API. Czym jest zatem REST? Rozwijając skrót, REST to Representational State Transfer. REST jest przede wszystkim sposobem na projektowanie API, czyli innymi słowy zestawem reguł i standardów, które należy spełnić aby nasze API było typu REST - wtedy takie API nazywane jest RESTful. Omawianie REST-a zaczniemy sobie właśnie od rozwinięcia poszczególnych słów, bo mają one duże znaczenie.
7. Zacznijmy od "RE" czyli Representational czyli po polsku można by to po prostu określić jako Reprezentacja. Żeby móc zrozumieć czym jest REprezentacja, musimy zestawić to sobie z przeciwieństwem do architektury REST, czyli z RPC - Remote Procedure Call, czyli tłumacząc na polski Zdalne Uruchomienie Komendy/Funkcji. 
8. Czym się charakteryzuje Remote Procedure Call? Tym, że API typu RPC definiuje nam pewne czynności jakie możemy wykonać korzystając z naszego serwisu np.:
	1. /getAllProducts - zwróć mi informacje o wszystkich produktach
	2. /listClients - wylistuj mi wszystkich klientów których mamy
	3. /predictProbability - przewidź prawdopodobieństwo jakiegoś zdarzenia. Tutaj notabene, osoby, które znają już RESTa wiedzą, że endpoint, który zdefiniowaliśmy w naszym API nie jest REST-owy. Ale zrobiłem to specjalnie, dlatego, że uczymy się dopiero projektowania API, więc zakładam zerową znajomość. Będziemy to potem poprawiać. 
9. Czyli jak widzicie serwis RPC będzie charakteryzował się endpointami, które samą swoją nazwą określają czynność.
10. Natomiast w przypadku REST API, będziemy pracowali na reprezentacjach tych obiektów, czyli zestawiając to z RPC endpointy wyglądałyby tak:
	1. /products
	2. /clients
	3. /probabilities
11. W tym przypadku nasze endpointy `/products` reprezentują produkty, `/clients` reprezentują klientów, a `/probabilities` reprezentują prawdopodobieństwo jakiegoś zdarzenia. To jakie akcje/czynności możemy wykonywać na naszych reprezentacjach, określane są przez metody z protokołu HTTP - czyli `GET`, `POST`, `PUT`, `DELETE` to co wszystko do tej pory poznaliśmy.
	1. `GET /products` - wyświetl nam informacje o wszystkich produktach
	2. `GET /products/{product_id}` - wyświetl nam informacje produkcie z danym ID.
	3. `POST /products/{product_id}` - dodaj informacje o danym produkcie
	4. `DELETE /clients/{client_id}` - usuń informacje o danym kliencie
	5. `POST /probabilities` - (zakładamy body w requescie) zwróci informacje o prawdopodobieństwie dla zadanych danych
12. Jaka jest zaleta podejścia REST w tym przypadku? To, że przy podejściu REST, praktycznie wystarczą nam tylko i wyłącznie 4 metody z protokołu HTTP - `GET`, `POST`, `PUT`, `DELETE` aby móc wykonać wszystkie możliwe czynności na danej reprezentacji. W sytuacji stosowania podejścia RPC, musielibyśmy definiować każdą czynność jaką możemy wykonać jako oddzielny endpoint. To jest jedna z zalet podejścia REST wobec RPC i porównanie tych dwóch podejść mam nadzieję, że ułatwiło Wam zrozumienie czym jest "REprezentacja". Czy podejście RPC jest wciąż wykorzystywane? W znacznie mniejszym stopniu, ale tak. Powiem o tym na końcu.
13. Natomiast trudność w REST jest w podejściu. Podejście RPC jest bardziej intuicyjne bo po prostu mówi o czynnościach, natomiast w REST musimy myśleć bardziej o reprezentacji/o pewnej abstrakcji która definiuje obiekt na którym będziemy mogli pracować. 
14. Słówko "S" oznacza State, czyli stan. W architekturze REST zakładamy, że API jest bezstanowe. Co to oznacza? 
	1. API "zapomina Nas" - wysyłamy request, jest przetwarzany, otrzymujemy odpowiedź i koniec. API nie zapamiętuje Nas i requesty są od siebie niezależne i nie powinny mieć wpływa na siebie. Czyli to jest ta sama zasada co w HTTP.
	2. To też ma taką konsekwencję, że request, który wysyłamy powinien być kompletny, tzn. zawiera w sobie wszystkie informacje niezbędne do tego aby API mogło przetworzyć nasze zapytanie.
15. Jak można zauważyć, REST bazuje mocno na protokole HTTP - posługujemy się reprezentacjami, na których możemy wykonywać operacje za pomocą różnych metod HTTP i też ma w sobie pojęcie bezstanowości, która w protokole HTTP jest obecna. REST został zdefiniowany w 2000 roku, a HTTP 1.1 w 1997, czyli mamy 3 lata różnicy. Krótko mówiąc, REST był pomysłem na podstawowego problemu w tamtych czasach - tzn. nie było standardu projektowania API, każdy "robił to po swojemu".  Architektura REST ukształtowała internet taki jaki znamy i REST jest używany praktycznie wszędzie a konkretne reprezentacji są zdefiniowane w URI i URLach, ale o URI i URLach powiemy sobie później. Aby nasze API stało się w pełni "RESTful" to musimy spełnić 6 zasad. Omówie te zasady bardziej ogólnie, a potem nawiąże co to dla Nas oznacza w przypadku serwisu MLowego.
	1. Uniform Interface - czyli jednolity interfejs. Tutaj sprawa jest prosta, bo powtórzę się w tym co mówiłem wcześniej:
		1. Bazujemy na reprezentacjach (`/products`), a nie na procedurach (czynnościach) `getAllProducts`, URI używane jako identyfikator zasobu/reprezentacji - o URI powiemy więcej później
		2. To metody z protokołu HTTP jak np. `GET` definiują to jakie akcje wykonujemy na danej reprezentacji
	2. Stateless - Znowu się powtórze, czyli bezstanowość - kolejne requesty/żądania nie zależą od siebie oraz sama treść requestu/żądania zawiera w sobie wszystkie niezbędne informacje (body, headers, parametry query) aby dane żądanie mogłobyć przetworzone przez API.
	3. Cacheable - Nasze odpowiedzi z API powinny móc być cache'owane, czyli trzymane w pamięci podręcznej. Dlaczego? Dlatego, że to znacznie przyspiesza działanie naszego serwisu, jeżeli pewne powtarzalne requesty możemy obsłużyć wyciągać odpowiedź z pamięci podręcznej, a nie znowu wyliczając albo przetwarzając coś na nowo. My takie cachoewanie będziemy implementować w naszym API później. (Pokaż na przykładzie np. stackoverflow jak wygląda cacheowanie)
	4. Client-Server Separation - separacja klienta z serverem. W tym przypadku klientem jesteśmy My, którzy wysyłamy żądanie, a serverem jest nasze API, które zwraca odpowiedzi. Komunikacja odbywa się jednostronnie, tzn. klient może wysłać do servera request, a server odpowiada (response). 
	   Ten punkt można zinterpretować tak że za kod/implementację, która spowoduje wysłanie żądania do naszego API odpowiada klient (My), a za kod/implementacje, która spowoduje przetworzenie żądania i wysłanie odpowiedzi odpowiada serwer (nasze API). Przy takim podziale komunikacji, nasze API w architekturze REST jest niezależne od oprogramowania klienckiego - on może je rozwijać w dowolny sposób i my możemy rozwijać nasze API w dowolny sposób bez większych wpływów na siebie.
	5. Layered System - Ten punkt jest trudniejszy, bo pojęcie proxy poznamy dopiero na zjeździe 3-cim, poświęconym Kubernetesowi, więc tutaj tylko wspomnę krótko: tak na prawdę nasze API nigdy nie będzie dostępne bezpośrednio. Zawsze będzie schowane za jakimś "pośrednikiem", który będzie pomiędzy klientem (My) a serwerem (API). Dlatego klient (My) nie może zakładać, że komunikuje się bezpośrednio z serverem, czy tym konkretnym pośrednikiem ORAZ z drugiej strony nasz warstwowy system (bo tych pośredników może być znacznie więcej) powinien przetworzyć te zapytanie tak samo, niezależnie od tego ile takich warstw zaimplementujemy.
	6. Code on Demand (niewymagane) - Ostatnia rzecz, nie wymagana, to taka, że nasze API może wysłać kawałek kodu, który zostanie uruchomiony u klienta. Przykładem tego mogą być skrypty JavaScriptowe, które są wysyłane w odpowiedzi i uruchamiane u Nas. W dokumentach HTML mamy wtedy tag `<script>`


16. Ok to są wszystkie zasady jakie obowiązuja w architekturze REST, natomiast chciałbym te rzeczy odnieść do naszego serwisu MLowego i co to dla nas Inżynierów ML te wszystkie zasady REST-owe oznaczają:
	1. Tak jak sami widzicie w kodzie, ten nasz serwis MLowy jest bardzo prosty. Tak na prawdę mamy w nim tylko dwa endpointy - jeden odpowiedzialny za wykonywanie predykcji, a drugi za dokumentację. Jak będziecie mieli okazje zobaczyć serwisy CRUD np. napisane w Django albo innym frameworku to zobaczycie, że nasz serwis w stosunku do serwisów typu CRUD to pryszcz. A jak spojrzmy sobie z kolei na ten zestaw reguł, to wydaje się on dosyć spory - w dodatku dla osób mających pierwszy kontakt z projektowaniem API może to być troszkę przytłaczające - mamy mały serwis, a tyle reguł, i w dodatku niektóre z nich mogą być nie do końca jasne.
	2. Prawda jest taka, że te reguły/zasady, które zostały przede mnie przedstawione są już niejako zaimplementowane out-of-the-box w frameworkach, technologiach, które będziemy używać do wdrożenia modelu. Warto pamiętać o fundamentach serwisów RESTowych, tak żeby wyczuć, że to co implementujemy może nie być RESTowym serwisem, natomiast nie musimy aż tak mocno się skupiać na pewnych regułach i zastanawiać się nad nimi mocno, bo one będą już automatycznie zaimplementowane w naszym API.  Wyjaśnie Wam to o czym inżynier ML musi pamiętać w trakcie projektowania API, a co już będzie "gotowe":
		1. Uniform Interface - my inżynierowe ML musimy myśleć o reprezentacjach w naszym serwisie - w praktyce spotykam się z dwoma podejściami. Pokaże to na naszym przykładzie
		   1) `decisions`, `probabilities`, `risk_categories` - czyli każdy output z modelu będzie miał swoją własną reprezentację
		   2) albo `predictions` - po prostu jedna reprezentacja predykcje, a rodzaj predykcji jest sterowany za pomocą parametrów query
		      Będziemy zaraz implementować te dwa podejścia i zobaczycie za i przeciw i powiem które ja rekomenduje z doświadczenia.
		      Czyli myślimy w kategoriach rzeczowników/reprezentacjach (`decisions`), a nie funkcjach/czynnościach (`predictDecision`)
		2. Stateless - czyli kolejne requesty/żądania nie zależą od siebie oraz sama treść requestu/żądania zawiera w sobie wszystkie niezbędne informacje. W naszym przypadku sprawa jest prosta. Do API MLowego wysyłane są po prostu dane, które są wpuszczane do modelu i dostajemy spowrotem predykcje/decyzję z modelu. Koniec działania. Sama logika działania modelu i tego co wymaga powoduje, że bardzo trudno jest nam naruszyć tą regułę w naszym API. W tym miejscu powiem Wam ciekawostkę jak działa API do OpenAI i ChatGPT. [ChatGPT](https://chat.openai.com/) "pamięta" poprzednie wiadomości i można prowadzić z nim konwersacje. Na tej podstawie można sądzić, że każdy kolejny request, a w tym przypadku każdy kolejny request  to  wiadomość zależą od siebie, więc ich API nie jest Stateless a jest Stateful, czyli narusza zasady REST. Natomiast prawda jest taka, że w momencie kiedy wstawiamy wiadomość w ChatGPT to cała konwersacja poprzednia, która tutaj jest jest dodawana do tej wiadomości i taka połączona wiadomość jest wysyłane do API. W tym API nie ma zachowanego stanu, tylko każdy request zawiera w sobie całą wcześniejszą konwersację. I tak dzieje się dalej. Czyli każdy request, zgodnie z zasadą RESTową jest niezależny od siebie i zawiera w sobie wszystkie informacje (w tym przypadku całą poprzednią konwersację) wymaganą do tego aby móc odpowiednio przetworzyć nasze zapytanie, czyli w tym przypadku naszą wiadomość. 
		3. Cacheable - z cacheowaniem w MLowym API jest pewne wyzwanie. W dużej mierze będzie to obsłużone przez proxy/web-serwer (np. [nginx](https://www.nginx.com/blog/nginx-caching-guide/)), czyli pośrednika, który stoi pomiędzy naszym MLowym serwisem, a klientem, który odpytuje. Natomiast trzeba to skonfigurować w proxy aby takie cache'owanie było. Temat Load Balancerów i Web Serwerów to temat bardziej dla DevOpsów i System ADministratorów a nie dla nas Inzynierów ML, choć podstawowa znajomość ich działania będzie omówiona na zjeździe 3-cim, poświęconym Kubernetesowi. Natomiast my będziemy implementować cacheowanie, ale nie na poziomie proxy, a na poziomie naszego API. Z punktu widzenia architektury systemów, to jest jakieś rozwiązanie, ale nie najlepsze. Ale chciałbym je Wam pokazać, bo jest stosunkowo proste i daje bardz   
		4. Nasze odpowiedzi z API powinny móc być cache'owane, czyli trzymane w pamięci podręcznej. 






Kiedy stosować RPC? Kiedy projektujemy API w warunkach, w których mamy wymagania bardzo niskich czasów przetwarzania zapytań. Niestety praca z gRPC jest zdecydowanie trudniejsza ze względu na to, że dane przesyłąne są w formacie binarnym, wiadomości są kodowane w protobufach i nie ma tak przyjemnych bibliotek jak FastAPI.

https://cloud.google.com/blog/products/application-development/rest-vs-rpc-what-problems-are-you-trying-to-solve-with-your-apis
https://www.restapitutorial.com/lessons/whatisrest.html

https://blog.bytebytego.com/p/why-is-restful-api-so-popular

https://cloud.google.com/blog/products/application-development/rest-vs-rpc-what-problems-are-you-trying-to-solve-with-your-apis

https://www.ovhcloud.com/pl/learn/what-is-rest-api/

https://www.reddit.com/r/explainlikeimfive/comments/rypnmj/eli5_what_is_a_rest_api/

https://www.moesif.com/blog/technical/api-design/REST-API-Design-Best-Practices-for-Parameters-and-Query-String-Usage/

https://danielmiessler.com/p/difference-between-uri-url/