# Definicja reprezentacji w API

1. Wróćmy teraz do naszego kodu i przyjrzymy się naszemu endpointowi. Tak jak widać, brzmi on `predict_decision` co bardziej odpowiada architekturze RPC niż REST, więc jest to rzecz do zmiany. 
2. Chciałbym Wam pokazać dwa sposoby podejścia do reprezentacji w serwisach MLowych, z którymi się spotkacie. Mają swoje zalety i wady i powiem Wam, którą ja rekomenduje.
3. Jak iwdzicie na ten moment mamy zdefiniowany jeden endpoint dla jednego rodzaju outputu z modelu. Jak przejdziemy sobie do klasy `CreditScoringModel` możemy zauważyć, że mamy 3 rodzaje outputów - decyzje, prawdopodobieństwa i kategoria ryzyka. Teraz.... jak można do tego podejść? Są dwa sposoby:
	1. Pierwszy z nich zakłada aby stworzyć oddzielne reprezentacje i w konsekwencji oddzielne endpointy dla każdego rodzaju outputu jaki model zwraca. Czyli mielibyśmy 3 reprezetnacje: `probabilities`, `decisions` oraz `risk_categories`
	2. Drugi sposób zakłada, aby stworzyć jedną reprezentację, która można by nazwać `predictions` natomiast to jaki rodzaj/kształt przyjmą te predykcje zależy od tego jakie parametry przekażemy do naszego żądania.
4. Zaczniemy od implementacji tego drugiego sposobu, czyli mamy jedną reprezentację `predictions` i odpowiednio będziemy sterować co chcemy otrzymać na wyjściu.
5. Na początek przejdźmy sobie do pliku `responses.py` i zdefiniujmy dodatkowe odpowiedzi, które będą nam teraz potrzebne. Zkopiujmy nasz `PredictDecisionResponse` i zmodyfikujmy odpowiednio:

```python
class PredictProbabilityResponse(BaseModelExtraFieldsForbidden):  
    probability: float = Field(  
        default=...,  
        title="Probability",  
        description="Probability of default for credit application.",  
    )  
  
class PredictRiskCategoryResponse(BaseModelExtraFieldsForbidden):  
    risk_category: RiskCategory = Field(  
        default=...,  
        title="Risk Category",  
        description="Risk category of credit application.",  
    )
```

W dodatku u góry zdefiniujemy sobie obiekt, który będzie przechowywał nam jakie mamy rodzaje odpowiedzi, to nam znacznie pomoże przy implementacji tego sposobu, który teraz robimy:

```python
from enum import Enum

class ResponseType(str, Enum):  
    decision = "decision"  
    probability = "probability"  
    risk_category = "risk_category"
```

6. Ok mamy to teraz przejdźmy do naszego `main.py` i zmodyfikujmy odpowiednio nasz endpoint aby obsłużyć te rozwiązanie. Zaimportujmy sobie nasze nowe odpowiedzi:

```python
from src.service.schemas.responses import (  
    PredictDecisionResponse,  
    PredictRiskCategoryResponse,  
    PredictProbabilityResponse,  
    ResponseType,
)
```

7. Zacznijmy od tego aby nazwać nasz endpoint tak jak powinniśmy w przypadku tego rozwiązania i będzie to po prostu `predictions`.

```python
@app.post("/predictions")  
async def predictions(request: PredictRequest) -> PredictDecisionResponse:
```

Nasze ciało funkcji trzeba teraz odpowiednio zmodyfikować, aby móc obsłużyć te trzy rodzaje outputów. Aby móc to osiągnąć musimy zaimportować sobie jeszcze dwa elementy - jeden z `fastapi`, drugi z `typing` czyli:

```python
from fastapi import Query
from typing import Annotated
```

i dodajmy do naszego endpointa:

```python
@app.post("/predictions")
async def predictions(
    request: PredictRequest,
    response_type: Annotated[ResponseType, Query()],
) -> PredictDecisionResponse:
```

Teraz co to jest za dziwny twór? Jak Wam mówiłem na początku, FastAPI bardzo mocno opiera się o type hintowanie - to pozwala mu na generowanie automatycznie dokumentacji naszego API oraz na przekształcanie naszych obiektów w odpowiednie inne obiekty żeby nasze API działało tak jak chcemy. 

Teraz czym jest ten `Annotated`? 


Pytania: Dlaczego Query params a nie Headers?