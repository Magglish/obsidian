# Definicja reprezentacji w API

1. Wróćmy teraz do naszego kodu i przyjrzymy się naszemu endpointowi. Tak jak widać, brzmi on `predict_decision` co bardziej odpowiada architekturze RPC niż REST, więc jest to rzecz do zmiany. 
2. Chciałbym Wam pokazać dwa sposoby podejścia do reprezentacji w serwisach MLowych, z którymi się spotkacie. Mają swoje zalety i wady i powiem Wam, którą ja rekomenduje.
3. Jak iwdzicie na ten moment mamy zdefiniowany jeden endpoint dla jednego rodzaju outputu z modelu. Jak przejdziemy sobie do klasy `CreditScoringModel` możemy zauważyć, że mamy 3 rodzaje outputów - decyzje, prawdopodobieństwa i kategoria ryzyka. Teraz.... jak można do tego podejść? Są dwa sposoby:
	1. Pierwszy z nich zakłada aby stworzyć oddzielne reprezentacje i w konsekwencji oddzielne endpointy dla każdego rodzaju outputu jaki model zwraca. Czyli mielibyśmy 3 reprezetnacje: `probabilities`, `decisions` oraz `risk_categories`
	2. Drugi sposób zakłada, aby stworzyć jedną reprezentację, która można by nazwać `predictions` natomiast to jaki rodzaj/kształt przyjmą te predykcje zależy od tego jakie parametry przekażemy do naszego żądania.
4. Zaczniemy od implementacji tego drugiego sposobu, czyli mamy jedną reprezentację `predictions` i odpowiednio będziemy sterować co chcemy otrzymać na wyjściu.
5. Na początek przejdźmy sobie do pliku `responses.py` i zdefiniujmy dodatkowe odpowiedzi, które będą nam teraz potrzebne. Zkopiujmy nasz `PredictDecisionResponse` i zmodyfikujmy odpowiednio:

```python
class PredictProbabilityResponse(BaseModelExtraFieldsForbidden):  
    probability: float = Field(  
        default=...,  
        title="Probability",  
        description="Probability of default for credit application.",  
    )  
  
class PredictRiskCategoryResponse(BaseModelExtraFieldsForbidden):  
    risk_category: RiskCategory = Field(  
        default=...,  
        title="Risk Category",  
        description="Risk category of credit application.",  
    )
```

W dodatku u góry zdefiniujemy sobie obiekt, który będzie przechowywał nam jakie mamy rodzaje odpowiedzi, to nam znacznie pomoże przy implementacji tego sposobu, który teraz robimy:

```python
from enum import Enum

class ResponseType(str, Enum):  
    decision = "decision"  
    probability = "probability"  
    risk_category = "risk_category"
```

Ok mamy to teraz przejdźmy do naszego `main.py` i zmodyfikujmy odpowiednio nasz endpoint aby obsłużyć te rozwiązanie:




Pytania: Dlaczego Query params a nie Headers?