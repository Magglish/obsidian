# Logowanie

1. Słuchajcie, przechodzimy teraz do bardzo ważnego tematu jakim jest logowanie. Czym jest logowanie? To każdy z Was myślę, że wie, więc jednym zdaniem można to ująć jako: zapisywanie wszelkich zdarzeń zachodzących w aplikacji.
2. Moim zdaniem istnieją dwie rzeczy, bez których nawet prosty projekt, czy Proof of Concept po 3/6 miesiącach nie może wejść na produkcję:
	1. Logi - o czym teraz będziemy o tym rozmawiać
	2. Testy - o czym będziemy rozmawiać później
3. Część z Was może jeszcze pomyśleć o monitoringu, jako o trzecim elemencie niezbędnym - tutaj nie jestem przekonany czy jest to niezbędny element. To zależy też oczywiście od stadium rozwoju aplikacji - jeżeli jest to początek, to moim zdaniem może jeszcze wejść jeszcze bez monitoringu, bo często monitoring oprócz takich fundamentalnych, podstawowych metryk musi też monitorować "specyficzne" metryki dla danego API, które po pierwszych iteracjach dopiero będą znane. Później jak już aplikacja jest bardziej dojrzała to oczywiście monitoring musi być. Natomiast mówiąc o takich niezbędnych elementach - niezależnie od tego w jakim jest stadium, czy to sam początek, czy już coś bardziej rozwiniętego, to jednak logowanie i testy jest must-have. Ja osobiście nie wdrażam nic na produkcję bez tych dwóch rzeczy - nie ma opcji.
4. Dlaczego? Dlatego, że naprawa bugów i debugowanie czegoś bez tych dwóch rzeczy to ISTNY KOSZMAR, zajmujący strasznie dużo czasu. Ja wole sobie tego zaoszczędzić.
5. Teraz porozmawiamy sobie o logowaniu w API. Od razu na wstępie powiem tak: 
	1. Pierwsza sprawa najważniejsza moim zdaniem -  chciałbym na tym zjeździe przekazać Wam najważniejsze punkty - ideę logowania: chciałbym żebyśmy mogli odpowiedzieć sobie na pytanie: KIEDY logować? CO logować? jak POWIĄZAĆ logi? Nie będziemy omawiać tutaj jak zbudowana jest pythonowa biblioteka logging i jak definiować w niej te wszystkie formattery, filtery itd. Nie nie. Chce się skupić na najważniejszych punktach - idei logowania. A to jaką bibliotekę finalnie użyjecie, to będzie to Wasza indywidualna preferencja. Z tym powiązaniem chodzi o to, że każdy log to będzie oddzielny wpis. Biorać pod uwagę fakt, że Wasze API będzie działało na wielu instancjach a zapytań wykonywach będzie wiele, to sami się przekonacie, że ilość logów jest ogromna. Zatem trzecie pytanie dotyczy w sumie jak się połapać w gąszczu tych wszystkich logów. O samym logowaniu można naprawdę pisać i wygłaszać elaboraty. Jak sobie sami spojrzycie np. w dyskusje na Stackoverflow oraz na Reddicie, każdy ma swoje zdanie na ten temat, są różne punkty widzenia. Ja przedstawie Wam tą wiedzę jaką zebrałem na bazie swojego doświadczenia + wzbogaconą o mieszanką wiedzy i doświadczeń innych developerów, czy to w trakcie rozmów czy właśnie analizy dyskusji na różnych forach. Najważniejsze moim zdaniem w logowaniu jest to, żeby Wam pomogło to w pracy - więc jeżeli będziecie uważać, że pewne rzeczy zrobilibyście inaczej i uważacie, że Wam się to lepiej sprawdzi - to jest ok, to to zróbcie.
	2. Druga sprawa - do logowania jest sporo bibliotek, znacznie lepszych niż zbudowany w pythonie moduł `logging`, który ma swoje wady - jedną z nich jest jego troche dziwna konfiguracja, przez co nie jest łatwa. Jest to bardzo stary moduł. Tych bibliotek jest sporo, ale moim zdaniem na największą uwagę zasługuje [logguru](https://github.com/Delgan/loguru) który znacznie upraszcza korzystanie z podstawowego `loggingu` oraz [structlog](https://www.structlog.org/en/stable/why.html), który skupia się na tworzeniu logów w formacie JSON. Niemniej jednak, każdy z nich korzysta pod spodem z pythonowego, podstawowego `logging`, więc warto poznać najpierw tą podstawową bibliotekę. Ja na naszym zjeździe zostanę przy podstawowym pythonowym `logging`-u - nie chce Wam wprowadzać nowych bilbiotek, które są kolejną warstwą nałożoną na podstawowy `logging`. I tak jak mówiłem, chce Wam przekazać ideę logowania - później w trakcie swojej pracy jak już oswoicie się z logowaniem to zdecydujecie, którą ostatecznie bibliotekę chcecie wykorzystywać.
	4. Trzecia sprawa - w sieci znajdziecie wiele różnych implementacji jak logować pewne zdarzenia. Bardzo często spotykanym patternem w temacie logowania jest decorator i przykładów decoratorów znajdziecie wiele - np. [ten](https://ankitbko.github.io/blog/2021/04/logging-in-python/). On jest wielki i troche brzydki - na pewno można go zapisać lepiej. Nie mniej jednak one będą tak wyglądać - jeżeli będziecie chcieli zrobić decorator, który będzie służył Wam zawsze i wszędzie, aby logował Wam to co chcecie, to będzie on skomplikowany. Ja Wam powiem z własnego doświadczenia, że... bawiłem się takimi decoratorami, które mogłyby logować wszystko co chce... i w moim przypadku się to nie sprawdza. Do logowania prostych funkcji tak, ale z bardziej skomplikowaną logiką już nie. Zawsze powstawał mi taki kolos, który ciężko było utrzymać i rozwijać gdy pojawiały się jakieś funkcje, które wyjątkowo inaczej musiałem zlogować. Ja porzuciłem ten pomysł i robie to prosto... po prostu dodając logowanie jako kolejne linijki kodu. Jeżeli natomiast Wy macie lepsze doświadczenia z tym związane i uważacie decoratory za fajny pattern do użycia w logowaniu i Wam się sprawdza... to jak najbardziej z tego korzystajcie. Natomiast ja nie będę ich używał na naszym zjeździe - pójdę w prostotę.


Ok to zacznijmy od początku:

1. Kiedy warto logować? 

Generalnie sprawa z pytaniem KIEDY warto logować jest stosunkowo prosta:

1. Na początku wywołania funkcji - aby mieć informacje zwrotną, że faktycznie rozpoczęło się jej wykonanie
2. Oraz na końcu wywołania funkcji - aby mieć informację zwrotną, że faktycznie funkcja zakończyła się. Z logowaniem na końcu funkcji jest jeszcze jedna istotna właściwość - oznacza to, że funkcja wykonała się prawidłowo. 
3. Natomiast jeżeli istnieje jakiś element w środku wywołania funkcji, który naszym zdaniem jest istotny i warto wiedzieć, że coś się wtedy zadziało, to także warto to logować.
4. I oczywista, oczywistość - logowanie każdego wyjątku/błędu, który wystąpi w funkcji - to jest najważniejsze.

Dodajmy sobie pierwsze logi do naszego API. Wróćmy do `main.py` i spójrzmy jak wygląda wywołanie kodu.

Dodajmy do maina taki kawałek kody:

```python
import logging  
from src.utils.logging import setup_logging  
```

A następnie na samym początku skryptu dodajmy:

```python
setup_logging()
```
Powiem później co to robi.

Mamy wywołanie `app = FastAPI()` - czy tutaj można dodać logi? Można. Ale zajmiemy się tym na końcu.

Dalej mamy wywołanie naszego modelu `model = CreditScoringModel(path=Path("models/classifier.pkl"))`.  Czy mamy tutaj logi? Nie mamy. Czy według nas jest to istotna rzecz, żeby zlogować? Moim zdaniem tak. Model w API to podstawowy komponent działania naszego modelu, jeżeli nie moglibyśmy go załadować, to chcielibyśmy wiedzieć dlaczego.

W takim razie dodajmy sobie logowanie do naszego modelu.
Zaimportujmy sobie moduł `logging`

```python
import logging
```

I do ładowania modelu dodajmy sobie logowanie:

Tak jak wspominałem: ważny jest początek i koniec. Zatem:

```python
logging.info(f"Loading Credit Scoring Model from {path} location")
```

Na początku wywołania funkcji. Oraz:

```python
logging.info(f"Successfully loaded Credit Scoring Model from {path} location")
```
Na końcu wywołania funkcji. Jeżeli logowania dojdzie do tego momentu, mamy również gwarancję tego, że bez problemu udało się nam załadować model. 

Dodatkowo wspomniałem o tym, że istotne jest również zastanowienie się czy w środku wywołania funkcji, innymi słowy pomiędzy startem logowania i końcem logowania jest coś istotnego. W tym przypadku oczywiście, że jest - sam proces załadowania obiektu. Co się może tutaj zdarzyć? Oczywiście fakt taki, że dany obiekt nie istnieje i to jest ten istotny element, o którym warto byłoby wiedzieć. W przypadku braku obiektu dostaniemy błąd, więc musimy go sobie zlogować: Zatem dodajmy sobie

```python
try:  
    with path.open(mode="rb") as file:  
        model = pickle.load(file)  
except FileNotFoundError as e:  
    logger.exception(f"Credit Scoring Model not found in {path} location.")  
    raise e
```
Teraz ktoś z Was może się zastanowić po co dodajemy do kodu takiego try excepta i logging.exception, skoro w Pythonie gdy pojawi się błąd to otrzymamy w konsoli jego treść? 

Zobaczmy na przykładzie: w `main.py` popsujmy lokalizacje naszego modelu i zobaczmy co otrzymamy. Jak widzicie pojawił się log:

```
Credit Scoring Model not found in models/classifier.pklxxx location.
```

I wraz z nim jest Traceback. `logging.exception` działa tak, że jeżeli zawrzemy go w klauzuli `try except` to domyślnie dołączony będzie traceback z błędem.

Ale zobaczcie co jest na dole: Znowu jest traceback... Czyli widzicie, informacja jest jakby powielona. Ten drugi błąd wynika, z tego, że tak działa pythonowy interpreter, który będzie printował nam w konsoli błąd jeżeli taki napotkamy. No właśnie i teraz powtarzając pytanie - ktoś z Was może się zastanowić po co dodajemy do kodu takiego try excepta i logging.exception, skoro w Pythonie gdy pojawi się błąd to otrzymamy w konsoli jego treść? Powody są dwa:
1. Na produkcji nie będziecie mieli takiej konsoli, która Wam printuje to na żywo. Logi będą wysyłane gdzieś do jakiegoś systemu - Google Cloudzie jest to Stackdriver, na AWS jest to CloudWatch, na Azurze jest to Azure Logs Monitor, jeśli będzie Wasze API stało na jakimś systemie on-premise to na pewno będzie jakiś serwis z logami. Biblioteki, które będą wysyłały logi do tych usług będą zintegrowane z podstawowym pythonowym `logging`, więc użycie ich będzie bardzo proste i bardzo często nawet nie będziecie musieli zmieniać swojego kodu.
2. Ten traceback, który teraz zaznaczam i który został wyprintowany przez pythonowy interpreter - nie macie żadnej gwarancji, że on zostanie wysłany do tego systemu obsługujący logi. Tak może być, ale nie musi. Np. na Google Cloudzie tak jest, że to co wyprinuje pythonowy interpreter to pojawi sie tam w logach, ale problem jest taki, że będzie to bardzo źle sformatowane i nie do przeczytania. Natomiast to co teraz zaznaczam, będzie JEDNYM wpisem w waszym systemie do analizy logów i będzie on poprawnie sformatowany. 
Więc najlepiej jest przyjąć takie założenie: na produkcji będziecie widzieć tylko to co sami sobie zlogowaliście - nic więcej. 

Teraz ktoś z Was może sobie zadać pytanie: A co jeżeli wystąpi tutaj inny błąd niż `FileNotFoundError`, jak powinniśmy ten błąd obsłużyć? To jest bardzo dobre pytanie. Generalnie obsługujemy te błędy, których się spodziewamy z samego działania kodu - zobaczcie, ja tutaj mam `pickle.load(...)` ja wiem co ta funkcja ma zrobić - wczytać plik, więc spodziewam się, że jak tego pliku nie będzie to po prostu rzuci wyjątkiem `FileNotFoundError` dlatego go wyłapałem i zlogowałem. A co jeżeli sam `pickle.load` rzuci w sobie jakiś błąd - dajmy na to ktoś spartolił implementacje tej metody i np. dostaliśmy błąd `AttributeError` - czy powinniśmy to zlogować? Oczywiście, że tak. Ale jak? Sposób jaki może przychodzić do głowy to to aby zastąpić `FileNotFoundError` najbardziej szerokim wyjątkiem czyli `Exception`. To jest jakieś rozwiązanie, ale jest to generalnie uznawane za bad practise. Dlaczego? Dlatego, że w takim przypadku Wasze logi będą nieprecyzyjne - każdy błąd który wystąpi w kodzie odpowiedzialnym za wczytanie modelu będzie traktowany tak samo, z tą samą treścią. I za każdym razem będziecie otrzymywać to samą wiadomość - niezależnie od tego czy faktycznie model jest w tej lokalizacji czy np. właśnie w `pickle.load(...)` jest jakiś bug. 
Ok, to ktoś może teraz pomyśleć - to może napiszmy ten log tak bardziej ogólnie, nie logujmy `Credit Scoring Model not found in {path} location.`, tylko np. napiszmy "Theres a problem with loading scoring models: {path=}.". To powiem Wam od razu, że takie generalne logi nie powiedzą Wam nic. Logi muszą być precyzyjne, zawierać w sobie wszelkie niezbędne informacje żebyście nie mieli żadnych wątpliwości co się zadziało, one mają Wam pomóc w Waszej pracy - natomiast takie generalne logi i łapanie szerokich wyjątków są niezbyt precyzyjne i w efekcie nie dadzą Wam żadnych korzyści. 

Wróćmy zatem do `FileNotFoundError` oraz do treści jaka była. Ok to co w sytuacji kiedy kod będzie rzucał więcej wyjątków niż jeden? To wtedy tych `exceptów` oraz `logging.exception` w naszym kodzie będzie znacznie więcej. 

O tym powiem Wam więcej, przy tematach związanych z wyłapywaniem błędów w API, których nie przewidzieliśmy ale o tym porozmawiamy na samym końcu tematu związanego z logowaniem.

Wróćmy do `main.py` i obsłużmy sobie jeszcze połączenia z bazami danych. Połączenia z bazami danych też są istotne, bo Redis przyśpiesza nam działanie naszego API a Postgres pozwala nam na zapisanie inputów i outputów z API, które potem stanowić będą baze do monitoringu.

W kodzie na redis w metodzie `_create_connection` brakuje sprawdzenia, czy udało nam się z tym Redisem połączyć. Akurat biblioteka do Redisa nie sprawdza połączenia z baza w momencie tworzenia tego połączenia, trzeba ją pingnąć:

Importujemy logging
```python
import logging
```
I dodajmy logowanie:

```python
logging.info(f"Creating connection to Redis database on {host=}, {port=}.")  
try:  
    connection = redis.Redis(host=host, port=port)  
    connection.ping()  
except redis.exceptions.ConnectionError as e:  
    logging.exception(f"Unable to connect to Redis database on {host=}, {port=}")  
    raise e  
logging.info(f"Successfully created connection to Redis database on {host=}, {port=}.")  
return connection
```

Został nam jeszcze postgres. 

Zaimportujmy logging a następnie w metodzie `_create_connection` dodajmy logowanie:

```python
logging.info("Creating connection to Postgres database.")  
try:  
    connection = psycopg2.connect(  
        database=database,  
        user=user,  
        password=password,  
        host=host,  
        port=port,  
    )except psycopg2.OperationalError as e:  
    logging.exception(f"Unable to connect to Redis database on {database=}, {user=}, {host=}, {port=}")  
    raise e  
logging.info("Successfully created connection to Postgres database.")  
return connection
```

W postgresie tworzony jest jeszcze cursor i tam też warto byłoby dodać logi... ale słuchajcie... umówmy się, że na potrzeby naszego spotkania nie będziemy dodawać logowania wszędzie OK? Zaraz oczywiście powiemy sobie CO warto logować. Natomiast nie chce dodawać logów wszędzie, bo spędzimy na tym za dużo czasu i spotkanie dobiegnie końca a jest wiele rzeczy jeszcze do omówienia. Aczkolwiek troche logów musimy dodać żebyśmy mieli w ogóle co analizować. Więc w przypadku Postgresa zostane na razie przy samym połączeniu, bez cursora.

I teraz ubijmy sobie `redis`a i `postgres`a -> znajdźmy je `docker ps` i zabijmy `docker kill <<PIERWSZE_ZNAKI_CONTAINER_ID>>` i sprawdźmy czy działa.

Pierwszy błąd powinien być związany z połączeniem z Redisem. Dobra to teraz stwórzmy go `make redis`. Spróbujmy jeszcze raz. Teraz wywaliło się na `Postgresie`. A teraz powinno zadziałać. Dobra, to było szybkie sprawdzenie czy faktycznie nasze logowanie zadziałało. 

**Pytanie**: Dlaczego zwykłe printy nie zadziałają?
Powodów jest wiele:
Odp: 
1. Formatowanie będzie kiepskie - np. logging.exception ma w sobie to aby sformatować cały traceback razem z nowymi liniami, znakami tabulacji itd.
2. Biblioteki do logowania pozwolą Ci na stworzenie struktury - np. JSON, który później łatwiej jest 
3. Jeżeli masz strukture JSONa to można łatwo dodać wszelkie metadane pozwalające na jeszcze łatwiejsze zdebugowanie kodu
5. Printy piszą do konsoli, która na produkcji nie zawsze może być dostępna
6. Logging pozwala Ci na definiowanie poziomu logów - DEBUG, INFO, WARNING, ERROR itd.
7. I najwazniejsz argument - na produkcji logi będą wysyłane do jakiegoś systemu: np. na Google Cloudzie jest to Stackdriver, na AWS jest to CloudWatch itd. I biblioteki, które wysyłają logi do tych usług są zintegrowane z podstawowym modułem `logging`, ale nie ze zwykłymi `print`
8. Prawdę powiedziawszy, gdybyś się uparł to mógłbyś napisać swój własny kod do logowania oparty o printy, pewnie byłoby to trudne ale możliwe - ale po co implementować koło na nowo? 

**Pytanie**: Co z `logging.getLogger(__name__)`
Jeżeli ktoś z Was już korzystał z `logging`-u wcześniej, to na pewno zna kod:

```python
logger = logging.getLogger(__name__)
```
Natomiast nie bedziemy z niego korzystać, tak jak mówiłem, nie chce omawiać dokładnie jak działa pythnowy moduł `logging`, a skupić się na samej idei. 


https://guicommits.com/how-to-log-in-python-like-a-pro/


2. Co warto logować?



3. Jak powiązać logi?