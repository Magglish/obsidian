# Testy obciążeniowe

**DO TESTÓW TYCH BEDZIE POTRZEBNY GENRATOR PRZYKŁADOWYCH REQUESTÓW. POWINIEN BYC W KODZIE ALE GDYBY GO BRAKOWAŁO TO:**

```python
import sys  
import pydantic  
  
from src.features.categories import (  
    CategoryEnum,  
)  
from typing import TypeVar  
import random  
from src.service.schemas.requests import BaseRequest  
  
Category = TypeVar("Category", bound=CategoryEnum)  
Request = TypeVar("Request", bound=BaseRequest)  
  
  
class ExampleRequestGenerator:  
    """Generates example requests with data for given request class."""  
  
    def __init__(self, request_cls: type[Request]) -> None:  
        """  
        Initalization of example request generator.  
        Args:            request_cls: Request class for which we want to generate example requests with fake data.        """        self.request_cls = request_cls  
        self.request_fields = request_cls.__fields__  
  
    def generate(self) -> Request:  
        """  
        Generates one example request with fake data  
        Returns:            Request object.        """        generated_values = {}  
        for field_name, field in self.request_fields.items():  
            generated_values[field_name] = self._generate_value(field)  
        return self.request_cls(**generated_values)  
  
    def _generate_value(self, field: pydantic.fields.ModelField) -> str | float | int:  
        """  
        Generates value for given field.  
        Args:            field: Details about the field in request class.  
        Returns:            String, float or int - depends on the field.        """        generation_functions = {  
            pydantic.types.ConstrainedInt: self._generate_int_value,  
            pydantic.types.ConstrainedFloat: self._generate_float_value,  
            CategoryEnum: self._generate_category_value,  
        }        return next((func(field) for type_, func in generation_functions.items() if issubclass(field.type_, type_)))  
  
    @staticmethod  
    def _generate_category_value(field: pydantic.fields.ModelField) -> str:  
        """  
        Generates example category value from category field.  
        Args:            field: Details about the category field in request class.  
        Returns:            Random category        """        categories = list(field.type_.mapping().values())  
        return random.choice(categories)  
  
    def _generate_int_value(self, field: pydantic.fields.ModelField) -> int:  
        """  
        Generates example int value from integer field with respect to the min and max value constraints.  
        Args:            field: Details about the integer field in request class.  
        Returns:            Random int value        """        return random.randint(*self._check_min_max_value(field))  
  
    def _generate_float_value(self, field: pydantic.fields.ModelField) -> float:  
        """  
        Generates example float value from float field with respect to the min and max value constraints.  
        Args:            field: Details about the float field in request class.  
        Returns:            Random float value        """        return random.uniform(*self._check_min_max_value(field))  
  
    @staticmethod  
    def _check_min_max_value(field: pydantic.fields.ModelField) -> tuple[int | float, int | float]:  
        """  
        Checks min and max value in numeric fields.  
        Logic:        1. If there is no limit, set the minimum and maximum values to:            Minium = -9223372036854775807            Maximum = 9223372036854775807        Which is the `sys.maxsize` - maximum and minimum value that your computer can generate.        2. If there is a `greater/less than` and `greater/less and equal than` set up together,            we choose the `greater/less than` for min and max values.        3. In all other cases, we choose `greater/less than` or `greater/less and equal than`            (depending on which is set) for min and max values.  
        Args:            field: Details about the float field in request class.  
        Returns:            Tuple with (min, max) value        """        min_value = -sys.maxsize  
        if field.type_.ge is not None:  
            min_value = field.type_.ge  
        if field.type_.gt is not None:  
            min_value = field.type_.gt  
  
        max_value = sys.maxsize  
        if field.type_.le is not None:  
            max_value = field.type_.le  
        if field.type_.lt is not None:  
            max_value = field.type_.lt  
        return min_value, max_value
```