# Kiedy nie potrzebujesz Kubernetesa

Okej to skończyło naszą część ćwiczeniową jeśli chodzi o kubernetes. Chciałbym z wami jeszcze na sam koniec chwileczkę porozmawiać o wadach Kubernetesa oraz o wariancie kiedy go możecie nie potrzebować

Spośród wad możemy wymienić w sumie 4 najważniejsze:

Trudność i wysoki próg wejścia - Jak sami widzicie Kubernetes jest trudny  i ma wysoki próg wejścia. Nawet jeżeli znacie parametry,  potraficie poruszać się po dokumentacji i łatwo znaleźć potrzebne informacje to i tak i tak wciąż będzie to sprawiało pewne wyzwanie w ustawianiu tych parametrów. Bo dopiero po  zdeprywaniu wielu różnych aplikacji i zobaczeniu  jak one działają na waszym skejsie można sobie wyrobić pewną opinię intuicję na temat pewnych parametrów.  dlatego doświadczenie z kubernesem przechodzi z czasem jak wdrażacie nowe rozwiązania jak widzicie ona działają i przede wszystkim jak widzicie Z jakimi problemami się borykacie  i jak jesteście w stanie je rozwiązać.  przy tej ilości obiektów które są dostępne też pewne problemy można rozwiązywać na wiele różnych sposobów,  ale kubernetes już istnieje na rynku  już jakiś konkretny czas i pewne najlepsze praktyki zostały  już stworzone  Jednakże i tak i tak  mogą być one trudne w deploymencie Bo jak widzicie,  żeby coś działało w pełni na przykład na nasze API No to trzeba stworzyć wiele różnych obiektów odpowiedzialnych za wiele róznych rzeczy Ty generalnie wokół wdrożenia pojedynczej rzeczy zawsze jest stawianych wiele różnych obiektów. 
Koszt - czasowy (praca nad nim i zarząðzanie), ludzi (trzeba wykwalifikiowanych ludzi) - Przez to że kubernetes jest trudny i ma wysoki próg wejścia oznacza też to że potrzebujemy wykwalifikowanych ludzi którzy się tym znają,  dla firmy jest to dodatkowy koszt w postaci zatrudnienia takich specjalistów.  dodatkowy koszt związany jest z tym że trzeba też tym klastrami  zarządzać.  kubernetes wyręcza nas bardzo mocno w kwestii zarządzania samymi kontenerami i skalowania ich  natomiast to nie oznacza że my możemy zostawić klaster  samemu sobie.  trzeba też go dobrze skonfigurować, Trzeba zadbać o dostępy do pewnych zasobów na klastrze,  trzeba ustawić kwestię sieciowe  także jest mnóstwo kwestii zarządczych wokół samego klastra i to kosztuje czas i pieniądze.
Sieć w Kubernetes -  Kolejna sprawa jest to że zarządzanie siecią i komunikacją pomiędzy tymi obiektami które deployujemy na Kubernetesie  też jest pewien sposób wymagający.  oczywiście Kubernetes dostarcza dostarcza sam w sobie rozwiązań sieciowych  i istnieją dedykowane obiekty  za pomocą którymi możemy tymi plecami sieciowymi zarządzać na przykład Obiekty o nazwie NetworkPolicies, Jednakże praktyka pokazuje że to nie jest wystarczające  i często na klastrze znajdzie  się usługa tak zwana serwis Mesh,  która znacznie rozszerza możliwość sieciowe Kubernetesa, ale jest to Oddzielna dedykowana usługa wdrożona na klastry którą też trzeba dodatkowo zarządzać przez co daje dodatkowy element abstrakcji skomplikowania i tak dalej. Co bezpośrednio jest powiązane z punktem pierwszym i drugim.
Debugowanie  - I ostatni element to debugowanie aplikacji Bo wasze aplikacje na klastrze Mogą nie działać  nie tylko w wyniku bugów w waszym kodzie Ale również dochodzę do ich wszelkich kwestii sieciowe  i komunikacji pomiędzy konkretnymi wodami,  dochodzą  Do tego ustawienia klastra w momencie jego tworzenia.  więc Generalnie powodów dla których wasza aplikacja nie działa może być znacznie znacznie więcej niż tylko bug w kodzie. 

Więc podsumowując te wady,  kubernetes jest naprawdę świetnym narzędziem  ale jego głównym wadą jest to że jest on skomplikowany i trudny. 


Powstaje pytanie czy faktycznie powinniśmy go używać w każdej sytuacji.  oczywiście odpowiem brzmi nie kubernetes został stworzony w pewnym konkretnym celu,  o którym na początku wspominałem ale zaraz też o nim wspomnę.  więc kiedy możecie nie potrzebować kubernetesa?  generalnie Ja wyróżniam cztery takie sytuacje w których kubernetes może być wam niepotrzebny:


High-availability niewymagane - w pierwszą sytuacją w której kubernetes może być niepotrzebny jest sytuacja w której wasze aplikacje nie muszą być tzw. high-availability. Czyli Innymi słowy nie ma problemu w tym że wasze aplikacje są przez pewien czas niedostępne. Kubernetes tak jak widzieliście, Potrafi restartować Pody jeśli coś się w nich zadzieje,  albo na przykład odłączać się od serwisu Kiedy dane pod nie jest gotowy do przyjmowania requestów, zatem Kubernetes sam  w logice swojego działania  po prostu będzie starał się zadbać o to żeby wasze aplikacje były zawsze dostępne. Więc jeżeli nie masz takich wymagań,  jeżeli nie macie problemu z tym że na przykład wasze API działa na jakiejś VMce, która nagle padła, albo się zrestartowała, I np. przykład dostaniecie informacje o tym, Że wasze API nie działa po jakimś tam dłuższym czasie bo ktoś wam to zgłosił bo chciał z tego skorzystać  i nie macie z tym żadnego problemu że raz na jakiś czas to się stanie  no to nie macie potrzeby żeby wasze API było cały czas dostępne  więc kubernetes i Jego możliwości restartowania podów jeżeli coś się zadzieje nie tak, są Wam po prostu niepotrzebne.

Sam rządzasz VMKami i masz to świetnie zautomatyzowane - Druga sytuacja jest taka kiedy możecie mieć już VMki stworzone. I świetnie sobie z nimi radzicie,  macie dedykowane skrypty po to stworzone czy  po prostu używacie jakich dodatkowych usług mniejszych które wspomagają nas konkretnie w jakimś obszarze zarządzania waszymi VMkami  i czujecie się w tym dobrze  i Potraficie tym dobrze zarządzać  na Na tyle że po prostu nie potrzebujecie dodatkowych rzeczy,  to kubernetes w takiej sytuacji Może nie być wam w ogóle potrzebne. Dlaczego?  No bo generalnie już takich Kubernetes sobie troszeczkę otworzyliście poprzez swoje własne Skrypty i dodatkowe usługi ,z których korzystacie. Przez co zrezygnowanie z tego i przejście na jakąś  dedykowaną usługę która pozwoli to za was robić będzie wiązało się z bardzo dużym kosztem,  czasem itd. To może lepiej po prostu tego nie robić. W przypadku pracy na chmurze można użyć dedykowanych rozwiązań. w GCPie w Compute Engine jest Instance Groups co pozwala na zarządzanie wieloma VMkami, a np. na rozwiązania on-prem np. Vagrant https://www.vagrantup.com/ 

Kubernetes bazuje na kontenerach - Trzecia sytuacja dotyczy tego  jak została stworzona wasza aplikacja.  jak widzicie kubernetes opiera się o kontenery.  a generalnie w kontenerach działa  pojedynczy proces odpowiedzialny za konkretną pojedynczą usługę. Dedykowane kontener z API,  dedykowany kontener z postgresem, dedykowane kontener z redisem. Czyli jeden kontener różni się jedna konkretna aplikacja.  natomiast w rzeczywistości możecie spotkać się też z podejściem monolitycznym, w którym zakładamy że w ramach jednego aplikacji po prostu implementujemy Wszystkie komponenty.  proszę wyobrazić takie sytuacje Gdybyśmy my teraz w naszym repozytorium nie tylko zaimplementowali API,  ale również mielibyście kod na działanie bazy danych postgres,  kod na Działanie bazy danych  redisa,  Wyobraźcie sobie że jeszcze tutaj chcielibyśmy sobie zrobić jakiś stronę internetową i mielibyśmy frontend napisany w reakcie. Generalnie rzecz biorąc mielibyśmy takiego kolosa,  Monolita,  trzymanego w jednym repozytorium. Jakakolwiek zmiana w naszym repozytorium związana z na przykład frontendem oznaczałoby Wdrożenie generalnie wszystkiego na raz no bo jest ze sobą bardzo mocno powiązane.  Przy takim podejściu monolitycznym,  nie uda nam się tego skontenerować dlatego że w jednym kontenerze będzie działało wiele różnych procesów, Co psuje się z ideą konteneryzacji.  A w dodatku też byłby problem z skalowaniem takich rozwiązań bo Wyobraźmy sobie sytuację w której po prostu Potrzebujemy jeszcze jednej instancji z naszym API bo mamy duży ruch,  ale skalowanie takiego rozwiązania w górę oznaczałoby dostawienie nowej całej instancji, czyli pojawiła by się instancja nie tylko z kolejnym API, ale również instancja z frontendem i bazami danych. W takim podejściu monolitycznym nie wrzucimy tego w kontener, a w efekcie czego nie wrzucimy na klaster Kubernetesowy.


 natomiast takim generalnym najważniejszym powodem dla którego nie należałoby używać kubernetesa jest sytuacja w której nie potrzebujecie autoskalowane. Bo autoskalowanie i wszelkie wyzwania związane z dostawieniem nowej instancji I udostępnieniu jej - krótko mówiąc, żeby się nie powtarzać, chodzi głównie tutaj kwestia sieciowe - To jest główny cel w jakim Kubernetes powstał. Pozostałe powody które tutaj wymieniłem można dostosować do kubernetesa.  W pierwszym przypadku,  na pewno nie stracicie na tym że wasze API będzie high-availability. A w drugiej sytuacji  byłyby koszt z nauką nowego narzędzia ale w końcu po  zapoznaniu się z nim  mógł on spokojnie zastąpić naszą customową implementację do zarządzania wiemkami.  w przypadku 3 powodu,  moglibyśmy poświęcić czas na przepisanie aplikacji  w taki sposób aby każdy z elementów budował się indywidualnie jako dedykowany kontener. Natomiast z auto skalowaniem tak nie jest dlatego że  to w głównej mierze zależy od tego w jakim celu wasz API jest stworzone,  w jakich warunkach będzie ono działało,  W jakiej skali będzie odpytywane.  i jeżeli wdrażacie API,  w warunkach w których wiecie że wasz ruch do niego będzie stały w czasie i generalnie nie będzie cię obserwować żadnych wielkich  zmian w schemacie użytkowania  w ciągu dnia,  w ciągu tygodni,  w ciągu miesięcy To Kubernetes może nie będzie wam w ogóle potrzebny. W takiej sytuacji postawienie API na stałej liczbie VMek I wspomaganie się jakimś prostym narzędziem do ich zarządzania (żeby na przykład łatwiej uruchamiać nasze API w momencie kiedy VMka się zrestartuje) Może być w zupełności wystarczającym  narzędziem żeby spełnić wymogi  co do działania waszego API.  i nie będziecie potrzebowali całej tej skomplikowanej otoczki wokół wdrażania obiektów na klastry zarządzane przez Kubernetesa. Czyli ta potrzeba autoskalowania jest tym głównym powodem od którego powinno się uzależnić decyzję o tym czy idziemy w Kubernetesa czy nie. 
